-- @path CICD1=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore
-- @path CICD2=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module extractEnvironmentVariablesFromSteps;
create OUT : CICD2 from IN : CICD1;

abstract rule PipelineBlock {
	from
		input : CICD1!PipelineBlock
	to
		output : CICD2!PipelineBlock(
			agent <- input.agent,
			concurrencyGroup <- input.concurrencyGroup,
			environmentVariables <- input.environmentVariables->collect(environmentVariable | thisModule.Assignment(environmentVariable, Sequence{}, '', false)),
			inputs <- input.inputs,
			name <- input.name,
			outputs <- input.outputs,
			permissions <- input.permissions,
			shell <- input.shell,
			timeoutMinutes <- input.timeoutMinutes,
			workingDirectory <- input.workingDirectory
		)
}

rule Pipeline extends PipelineBlock {
	from
		input : CICD1!Pipeline
	to
		output : CICD2!Pipeline(
			triggers <- input.triggers,
			jobStreams <- input.jobStreams
		)
}

abstract rule Job extends PipelineBlock {
	from
		input : CICD1!Job
	to
		output : CICD2!Job(
			id <- input.id,
			ifCondition <- if not input.ifCondition.oclIsUndefined() then input.ifCondition.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			services <- input.services,
			matrix <- input.matrix,
			next <- input.next,
			previous <- input.previous,
			maxAttempts <- input.maxAttempts,
			allowFailure <- input.allowFailure,
			environmentVariables <- input.environmentVariables->collect(environmentVariable | thisModule.Assignment(environmentVariable, Sequence{}, '', false))
		)
}

rule ScriptJob extends Job {
	from
		input: CICD1!ScriptJob
	to
		output: CICD2!ScriptJob(
			steps <- input.steps->collect(step | step.step2StepHelper('STEP_' + input.steps.indexOf(step).toString().concat('_'))),			
			environmentVariables <- 
				input.environmentVariables
				->collect(environmentVariable | thisModule.Assignment(environmentVariable, Sequence{}, '', false))
				->union(input.steps->collect(step |
					if step.oclIsKindOf(CICD1!ConditionalStep) then
						step.thenRun->collect(thenStep | 
							thenStep.environmentVariables->collect(environmentVariable |
								thisModule.Assignment(environmentVariable, thisModule.getEnvironmentVariableNames(thenStep.environmentVariables), 
									'STEP_' + input.steps.indexOf(step).toString().concat('_THEN_STEP_').concat(step.thenRun.indexOf(thenStep).toString()).concat('_'),
									true
								)
							)
						)->flatten()->union(
							step.elseRun->collect(thenStep | 
							thenStep.environmentVariables->collect(environmentVariable |
								thisModule.Assignment(environmentVariable, thisModule.getEnvironmentVariableNames(thenStep.environmentVariables), 
									'STEP_' + input.steps.indexOf(step).toString().concat('_ELSE_STEP_').concat(step.elseRun.indexOf(thenStep).toString()).concat('_'),
									true
								)
							)
							)->flatten()
						)
					else
						step.environmentVariables->collect(environmentVariable |
							thisModule.Assignment(environmentVariable, thisModule.getEnvironmentVariableNames(step.environmentVariables), 'STEP_' + input.steps.indexOf(step).toString().concat('_'), true)
						)
					endif
					)->flatten()
				)
		)
}

rule PipelineCallJob extends Job {
	from
		input: CICD1!PipelineCallJob
	to
		output: CICD2!PipelineCallJob(
			pipelinePath <- if not input.pipelinePath.oclIsUndefined() then input.pipelinePath.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			args <- input.args->collect(environmentVariable | thisModule.Assignment(environmentVariable, Sequence{}, '', false))
		)
}

rule Agent {
	from
		input : CICD1!Agent
	to
		output : CICD2!Agent(
			labels <- input.labels->collect(label | label.expression2ExpressionHelper(Sequence{}, '')),
			container <- input.container
		)
}

rule DockerContainer {
	from
		input : CICD1!DockerContainer
	to
		output : CICD2!DockerContainer(
			label <- input.label,
			image <- if not input.image.oclIsUndefined() then input.image.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			environmentVariables <- input.environmentVariables->collect(environmentVariable | thisModule.Assignment(environmentVariable, Sequence{}, '', false)),
			volumes <- input.volumes->collect(volume | volume.expression2ExpressionHelper(Sequence{}, '')),
			ports <- input.ports->collect(port | port.expression2ExpressionHelper(Sequence{}, '')),
			options <- input.options,
			registryUsername <- if not input.registryUsername.oclIsUndefined() then input.registryUsername.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			registryPassword <- if not input.registryPassword.oclIsUndefined() then input.registryPassword.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			network <- if not input.network.oclIsUndefined() then input.network.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif
		)
}

abstract rule Trigger {
	from
		input : CICD1!Trigger
	to
		output : CICD2!Trigger(
			branchGlobs <- input.branchGlobs
		)
}

rule PushTrigger extends Trigger {
	from
		input : CICD1!PushTrigger
	to
		output : CICD2!PushTrigger(
			tagGlobs <- input.tagGlobs
		)
}

rule PullRequestTrigger extends Trigger {
	from
		input : CICD1!PullRequestTrigger
	to
		output : CICD2!PullRequestTrigger
}

rule ManualTrigger extends Trigger {
	from
		input : CICD1!ManualTrigger
	to
		output : CICD2!ManualTrigger
}

rule ScheduledTrigger extends Trigger {
	from
		input : CICD1!ScheduledTrigger
	to
		output : CICD2!ScheduledTrigger(
			crons <- input.crons
		)
}

rule WebhookTrigger extends Trigger {
	from
		input : CICD1!WebhookTrigger
	to
		output : CICD2!WebhookTrigger
}

rule ConcurrencyGroup {
	from
		input : CICD1!ConcurrencyGroup
	to
		output : CICD2!ConcurrencyGroup(
			cancelInProgress <- input.cancelInProgress,
			groupId <- if not input.groupId.oclIsUndefined() then input.groupId.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif
		)
}

rule Permission {
	from
		input : CICD1!Permission
	to
		output : CICD2!Permission(
			key <- input.key,
			value <- input.value
		)
}

rule Matrix {
	from
		input : CICD1!Matrix
	to
		output : CICD2!Matrix(
			axes <- input.axes,
			excludes <- input.excludes,
			includes <- input.includes,
			failFast <- input.failFast
		)
}

rule MatrixAxis {
	from
		input : CICD1!MatrixAxis
	to
		output : CICD2!MatrixAxis(
			name <- input.name,
			cells <- input.cells->collect(cell | cell.expression2ExpressionHelper(Sequence{}, ''))
		)
}

rule MatrixCombination {
	from
		input : CICD1!MatrixCombination
	to
		output : CICD2!MatrixCombination(
			combinationEntries <- input.combinationEntries->collect(combinationEntry | thisModule.Assignment(combinationEntry, Sequence{}, '', false))
		)
}

abstract rule Parameter {
	from
		input : CICD1!Parameter
	to
		output : CICD2!Parameter(
			description <- input.description,
			id <- input.id
		)
}

rule Input extends Parameter {
	from
		input : CICD1!Input
	to
		output : CICD2!Input(
			defaultValue <- input.defaultValue,
			required <- input.required,
			type <- input.type
		)
}

rule Output extends Parameter {
	from
		input : CICD1!Output
	to
		output : CICD2!Output(
			value <-
				if input.value.oclIsKindOf(CICD1!Variable) then
					thisModule.Variable(input.value, Sequence{}, '')
				else
					input.value
				endif
		)
}

lazy rule ConditionalStep {
	from
		input : CICD1!ConditionalStep,
		prefix : String
	to
		output : CICD2!ConditionalStep(
			ifCondition <- if not input.ifCondition.oclIsUndefined() then input.ifCondition.expression2ExpressionHelper(Sequence{}, '') else OclUndefined endif,
			thenRun <- input.thenRun->collect(step | step.step2StepHelper(prefix + 'THEN_STEP_' + input.thenRun.indexOf(step).toString().concat('_'))),
			elseRun <- input.elseRun->collect(step | step.step2StepHelper(prefix + 'ELSE_STEP_' + input.elseRun.indexOf(step).toString().concat('_')))
		)
}

lazy rule Command {
	from
		input : CICD1!Command,
		prefix : String
	using {
		environmentVariableNames : Sequence(String) = thisModule.getEnvironmentVariableNames(input.environmentVariables);
	}
	to
		output : CICD2!Command(
			name <- input.name,
			id <- input.id,
			allowFailure <- input.allowFailure,
			timeoutMinutes <- input.timeoutMinutes,
			environmentVariables <- Sequence{},
			program <- if not input.program.oclIsUndefined() then input.program.expression2ExpressionHelper(environmentVariableNames, prefix) else OclUndefined endif
		)
}

lazy rule Plugin {
	from
		input : CICD1!Plugin,
		prefix : String
	using {
		environmentVariableNames : Sequence(String) = thisModule.getEnvironmentVariableNames(input.environmentVariables);
	}
	to
		output : CICD2!Plugin(
			name <- input.name,
			id <- input.id,
			allowFailure <- input.allowFailure,
			timeoutMinutes <- input.timeoutMinutes,
			environmentVariables <- Sequence{},
			pluginName <- input.pluginName,
			version <- input.version,
			kwargs <- input.kwargs->collect(kwarg | thisModule.Assignment(kwarg, environmentVariableNames, prefix, false))
		)
}

lazy rule Cache {
	from
		input : CICD1!Cache,
		prefix : String
	using {
		environmentVariableNames : Sequence(String) = thisModule.getEnvironmentVariableNames(input.environmentVariables);
	}
	to
		output : CICD2!Cache(
			name <- input.name,
			id <- input.id,
			allowFailure <- input.allowFailure,
			timeoutMinutes <- input.timeoutMinutes,
			environmentVariables <- Sequence{},
			cacheName <- if not input.cacheName.oclIsUndefined() then input.cacheName.expression2ExpressionHelper(environmentVariableNames, prefix) else OclUndefined endif,
			keys <- input.keys->collect(key | key.expression2ExpressionHelper(environmentVariableNames, prefix)),
			paths <- input.paths->collect(path | path.expression2ExpressionHelper(environmentVariableNames, prefix)),
			store <- input.store
		)
}

lazy rule Artifact {
	from
		input : CICD1!Artifact,
		prefix : String
	using {
		environmentVariableNames : Sequence(String) = thisModule.getEnvironmentVariableNames(input.environmentVariables);
	}
	to
		output : CICD2!Artifact(
			name <- input.name,
			id <- input.id,
			allowFailure <- input.allowFailure,
			timeoutMinutes <- input.timeoutMinutes,
			environmentVariables <- Sequence{},
			artifactName <- if not input.artifactName.oclIsUndefined() then input.artifactName.expression2ExpressionHelper(environmentVariableNames, prefix) else OclUndefined endif,
			includePaths <- input.includePaths->collect(includePath | includePath.expression2ExpressionHelper(environmentVariableNames, prefix)),
			excludePaths <- input.excludePaths->collect(excludePath | excludePath.expression2ExpressionHelper(environmentVariableNames, prefix)),
			retentionTime <- if not input.retentionTime.oclIsUndefined() then input.retentionTime.expression2ExpressionHelper(environmentVariableNames, prefix) else OclUndefined endif,
			store <- input.store
		)
}

lazy rule Assignment {
	from
		input : CICD1!Assignment,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String,
		changeVariableName : Boolean
	to
		output : CICD2!Assignment(
			key <-
				if changeVariableName then
					thisModule.Variable(input.key, stepEnvironmentVariableNames, prefix)
				else
					thisModule.Variable(input.key, Sequence{}, '')
				endif,
			value <- if not input.value.oclIsUndefined() then input.value.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif
		)
}

lazy rule Variable {
	from
		input : CICD1!Variable,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!Variable(
			name <-
				if stepEnvironmentVariableNames.includes(input.name) then
					prefix.concat(input.name)
				else
					input.name
				endif
		)
}

lazy rule Concat {
	from
		input : CICD1!Concat,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!Concat(
			expressions <- input.expressions->collect(expression | expression.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix))
		)
}

lazy rule EqualityOp {
	from
		input : CICD1!EqualityOp,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!EqualityOp(
			lhs <- if not input.lhs.oclIsUndefined() then input.lhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			rhs <- if not input.rhs.oclIsUndefined() then input.rhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			op <-
				if input.op = #"==" then
					#"=="
				else
					#"!="
				endif
		)
}

lazy rule ComparisonOp {
	from
		input : CICD1!ComparisonOp,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!ComparisonOp(
			lhs <- if not input.lhs.oclIsUndefined() then input.lhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			rhs <- if not input.rhs.oclIsUndefined() then input.rhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			op <-
				if input.op = #">" then
					#">"
				else if input.op = #">=" then
					#">="
				else if input.op = #"<" then
					#"<"
				else
					#"<="
				endif
				endif
				endif
		)
}

lazy rule And {
	from
		input : CICD1!And,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!And(
			lhs <- if not input.lhs.oclIsUndefined() then input.lhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			rhs <- if not input.rhs.oclIsUndefined() then input.rhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif
		)
}

lazy rule Or {
	from
		input : CICD1!Or,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!Or(
			lhs <- if not input.lhs.oclIsUndefined() then input.lhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			rhs <- if not input.rhs.oclIsUndefined() then input.rhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif
		)
}

lazy rule Negation {
	from
		input : CICD1!Negation,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!Negation(
			rhs <- if not input.rhs.oclIsUndefined() then input.rhs.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif
		)
}

lazy rule VariableDereference {from
		input : CICD1!VariableDereference,
		stepEnvironmentVariableNames : Sequence(String),
		prefix : String
	to
		output : CICD2!VariableDereference(
			variable <- if not input.variable.oclIsUndefined() then input.variable.expression2ExpressionHelper(stepEnvironmentVariableNames, prefix) else OclUndefined endif,
			property <-
				if stepEnvironmentVariableNames.includes(input.property) then
					prefix.concat(input.property)
				else
					input.property
				endif
		)
}

abstract rule Literal {
	from
		input : CICD1!Literal
	to
		output : CICD2!Literal
}

rule StringLiteral extends Literal {
	from
		input : CICD1!StringLiteral
	to
		output : CICD2!StringLiteral(
			value <- input.value
		)
}

rule IntegerLiteral extends Literal {
	from
		input : CICD1!IntegerLiteral
	to
		output : CICD2!IntegerLiteral(
			value <- input.value
		)
}

rule DoubleLiteral extends Literal {
	from
		input : CICD1!DoubleLiteral
	to
		output : CICD2!DoubleLiteral(
			value <- input.value
		)
}

rule BooleanLiteral extends Literal {
	from
		input : CICD1!BooleanLiteral
	to
		output : CICD2!BooleanLiteral(
			value <- input.value
		)
}

rule VariableContext {
	from
		input : CICD1!VariableContext
	to
		output : CICD2!VariableContext(
			context <- 
				if input.context = #ENV then
					#ENV
				else if input.context = #PARAMS then
					#PARAMS
				else
					#""
				endif
				endif
		)
}

rule SecretVariable {
	from
		input : CICD1!SecretVariable
	to
		output : CICD2!SecretVariable(
			name <- input.name
		)
}

helper def : extractEnvironmentVariables(steps : Sequence(CICD1!Step)) : Sequence(CICD1!Assignment) =
	steps->collect(step | 
		if step.oclIsKindOf(CICD1!ConditionalStep) then
			thisModule.extractEnvironmentVariables(step.thenRun)->union(thisModule.extractEnvironmentVariables(step.elseRun))
		else
			step.environmentVariables
		endif
	)->flatten();

helper def : getEnvironmentVariableNames(environmentVariables : Sequence(CICD1!Assignment)) : Sequence(String) =
	environmentVariables->collect(environmentVariable | environmentVariable.key.name);

helper context CICD1!Expression def : expression2ExpressionHelper(stepEnvironmentVariableNames : Sequence(String), prefix : String) : CICD2!Expression =
	if self.oclIsKindOf(CICD1!Concat) then
		thisModule.Concat(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!ComparisonOp) then
		thisModule.ComparisonOp(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!EqualityOp) then
		thisModule.EqualityOp(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!And) then
		thisModule.And(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!Or) then
		thisModule.Or(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!Variable) then
		thisModule.Variable(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!Negation) then
		thisModule.Negation(self, stepEnvironmentVariableNames, prefix)
	else if self.oclIsKindOf(CICD1!VariableDereference) then
		thisModule.VariableDereference(self, stepEnvironmentVariableNames, prefix)
	else
		self
	endif
	endif
	endif
	endif
	endif
	endif
	endif
	endif;

helper context CICD1!Step def : step2StepHelper(prefix : String) : CICD2!Step =
	if self.oclIsKindOf(CICD1!ConditionalStep) then
		thisModule.ConditionalStep(self, prefix)
	else if self.oclIsKindOf(CICD1!Command) then
		thisModule.Command(self, prefix)
	else if self.oclIsKindOf(CICD1!Plugin) then
		thisModule.Plugin(self, prefix)
	else if self.oclIsKindOf(CICD1!Cache) then
		thisModule.Cache(self, prefix)
	else if self.oclIsKindOf(CICD1!Artifact) then
		thisModule.Artifact(self, prefix)
	else 
		OclUndefined
	endif
	endif
	endif
	endif
	endif;
