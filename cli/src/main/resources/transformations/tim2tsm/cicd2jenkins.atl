-- @path Jenkins=/d.fe.up.pt.cicd.jenkins.metamodel/model/Jenkins.ecore
-- @path CICD=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module cicd2jenkins;

create OUT : Jenkins from IN : CICD;

rule Pipeline2Pipeline {
	from
		cicdPipeline : CICD!Pipeline
	to
		jenkinsPipeline : Jenkins!Pipeline(
			stages <- thisModule.groupJobs(cicdPipeline.jobStreams, Set{})->collect(
						jobGroup | if jobGroup->size() = 1 then 
							if jobGroup->first().matrix.oclIsUndefined() then
								thisModule.Job2StepStage(jobGroup->first())
							else
								thisModule.Job2MatrixStage(jobGroup->first())
							endif
						else
							thisModule.JobSequence2Parallel(jobGroup)
						endif
						),
			agent <- 
				if cicdPipeline.agent.oclIsUndefined() then 
					thisModule.CreateAnyAgent('') 
				else 
					cicdPipeline.agent 
				endif,
			environmentVariables <- cicdPipeline.environmentVariables,
			triggers <- cicdPipeline.triggers
		)
	do {
		if (jenkinsPipeline.agent.oclIsTypeOf(Jenkins!NodeAgent) and not cicdPipeline.workingDirectory.oclIsUndefined()) {
			jenkinsPipeline.agent.customWorkspace <- cicdPipeline.workingDirectory;
		}
	}
}

lazy rule Job2StepStage {
	from
		job : CICD!Job
	to
		stage : Jenkins!StepStage(
			name <- job.id,
			agent <- job.agent,
			environmentVariables <- job.environmentVariables,
			steps <- job.steps,
			whens <- 
				if not job.ifCondition.oclIsUndefined() then
					Sequence{thisModule.Expression2WhenExpression(job.ifCondition)}
				else
					OclUndefined
				endif
		)
	do {
		if (stage.agent.oclIsTypeOf(Jenkins!NodeAgent) and not job.workingDirectory.oclIsUndefined()) {
			stage.agent.customWorkspace <- job.workingDirectory;
		}
	}
}

lazy rule Expression2WhenExpression {
	from
		expression : CICD!Expression
	to 
		when : Jenkins!WhenExpression (
			expression <- expression
		)
}

lazy rule Job2MatrixStage {
	from
		job : CICD!Job
	to
		stage : Jenkins!MatrixStage(
			name <- (job.id + '_matrix'),
			axes <- job.matrix.axes,
			includes <- job.matrix.includes,
			excludes <- job.matrix.excludes,
			failFast <- job.matrix.failFast,
			stages <- Sequence{thisModule.Job2StepStage(job)}
		)
}

rule MatrixAxis2MatrixAxis {
	from
		cicdAxis : CICD!MatrixAxis
	to
		jenkinsAxis : Jenkins!MatrixAxis(
			name <- cicdAxis.name,
			cells <- cicdAxis.cells
		)
}

rule MatrixCombination2MatrixCombination {
	from
		cicdCombination : CICD!MatrixCombination
	to
		jenkinsCombination : Jenkins!MatrixCombination(
			entries <- cicdCombination.combinationEntries
		)
}

lazy rule JobSequence2Parallel {
	from
		jobSequence : Sequence(CICD!Job)
	to
		abstractStage : Jenkins!ParallelNestedStage(
			name <- thisModule.joinStrings(jobSequence->collect(job | job.id), '||'),
			stages <- jobSequence->collect(job | thisModule.Job2StepStage(job))		
		)
}

rule ConditionalStep2ScriptedBlock {
	from
		cicdStep : CICD!ConditionalStep
	to
		jenkinsStep : Jenkins!ScriptedBlock(
			steps <- thisModule.ConditionalStep2ConditionalStep(cicdStep)
		)
}

lazy rule ConditionalStep2ConditionalStep {
	from
		cicdStep : CICD!ConditionalStep
	to
		jenkinsStep : Jenkins!ConditionalStep(
			ifCondition <- cicdStep.ifCondition,
			thenRun <- cicdStep.thenRun,
			elseRun <- cicdStep.elseRun
		)
}

rule Command2Step {
	from
		cicdStep : CICD!Command
	to
		jenkinsStep : Jenkins!Step(
			command <- 'sh',
			arguments <- cicdStep.program.expression2String()
		)
}

abstract rule Expression2Expression {
	from
		cicdExpression : CICD!Expression
	to
		jenkinsExpression : Jenkins!Expression
}

rule Concat2Concat extends Expression2Expression {
	from
		cicdExpression : CICD!Concat
	to
		jenkinsExpression : Jenkins!Concat(
			expressions <- cicdExpression.expressions
		)
}

abstract rule BinaryOp2BinaryOp extends Expression2Expression {
	from
		cicdExpression : CICD!BinaryOp
	to
		jenkinsExpression : Jenkins!BinaryOp(
			lhs <- cicdExpression.lhs,
			rhs <- cicdExpression.rhs
		)
}

abstract rule UnaryOp2UnaryOp extends Expression2Expression {
	from
		cicdExpression : CICD!UnaryOp
	to
		jenkinsExpression : Jenkins!UnaryOp(
			childExpr <- cicdExpression.rhs
		)
}

rule Negation2Negation extends UnaryOp2UnaryOp {
	from
		cicdExpression : CICD!Negation
	to
		jenkinsExpression : Jenkins!Negation
}

rule ComparisonOp2ComparisonOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!ComparisonOp
	to
		jenkinsExpression : Jenkins!ComparisonOp(
			op <- 
				if cicdExpression.op = #">" then
					#">"
				else if cicdExpression.op = #">=" then
					#">="
				else if cicdExpression.op = #"<" then
					#"<"
				else
					#"<="
				endif
				endif
				endif
		)
}

rule EqualityOp2EqualityOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!EqualityOp
	to
		jenkinsExpression : Jenkins!EqualityOp(
			op <- 
				if cicdExpression.op = #"==" then
					#"=="
				else
					#"!="
				endif
		)
}

abstract rule LogicalOp2LogicalOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!LogicalOp
	to
		jenkinsExpression : Jenkins!LogicalOp
}

rule And2And extends LogicalOp2LogicalOp {
	from
		cicdExpression : CICD!And
	to
		jenkinsExpression : Jenkins!And
}

rule Or2Or extends LogicalOp2LogicalOp {
	from
		cicdExpression : CICD!Or
	to
		jenkinsExpression : Jenkins!Or
}

rule VariableDereference2VariableDereference extends Expression2Expression {
	from
		cicdExpression : CICD!VariableDereference
	to
		jenkinsExpression : Jenkins!VariableDereference(
			variable <- cicdExpression.variable,
			property <- cicdExpression.property
		)
}

abstract rule Value2Value extends Expression2Expression {
	from
		cicdExpression : CICD!Value
	to
		jenkinsExpression : Jenkins!Value
}

rule Variable2Variable extends Value2Value {
	from
		cicdExpression : CICD!Variable
	to
		jenkinsExpression : Jenkins!Variable(
			name <- cicdExpression.name
		)
}

rule VariableContext2JenkinsContext extends Value2Value {
	from
		cicdExpression : CICD!VariableContext
	to
		jenkinsExpression : Jenkins!JenkinsContext(
			name <- 
				if cicdExpression.context = #ENV then
					#env
				else if cicdExpression.context = #PARAMS then
					#params
				else
					#""
				endif
				endif
		)
}

abstract rule Literal2Literal extends Value2Value {
	from
		cicdExpression : CICD!Literal
	to
		jenkinsExpression : Jenkins!Literal		
}

rule StringLiteral2StringLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!StringLiteral
	to
		jenkinsExpression : Jenkins!StringLiteral(
			value <- cicdExpression.value
		)	
}

rule IntegerLiteral2IntegerLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!IntegerLiteral
	to
		jenkinsExpression : Jenkins!IntegerLiteral(
			value <- cicdExpression.value
		)	
}

rule DoubleLiteral2DoubleLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!DoubleLiteral
	to
		jenkinsExpression : Jenkins!DoubleLiteral(
			value <- cicdExpression.value
		)	
}

rule BooleanLiteral2BooleanLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!BooleanLiteral
	to
		jenkinsExpression : Jenkins!BooleanLiteral(
			value <- cicdExpression.value
		)	
}

lazy rule CreateAnyAgent {
	from
		blank : String
	to
		agent : Jenkins!AnyAgent()
}

rule Agent2NodeAgent {
	from
		cicdAgent : CICD!Agent(
			cicdAgent.container.oclIsUndefined()
		)
	to
		jenkinsAgent : Jenkins!NodeAgent(
			labels <- cicdAgent.labels->first()
		)
}

rule Agent2DockerAgent {
	from
		cicdAgent : CICD!Agent(
			not cicdAgent.container.oclIsUndefined()
		)
	to
		jenkinsAgent : Jenkins!DockerAgent(
			labels <- cicdAgent.labels->first(),
			docker <- cicdAgent.container
		)
}

rule DockerContainer2DockerContainer {
	from
		cicdDockerContainer : CICD!DockerContainer
	to
		jenkinsDockerContainer : Jenkins!DockerContainer(
			image <- cicdDockerContainer.image.expression2String(),
			label <- cicdDockerContainer.label,
			args <- 
				thisModule.getDockerArguments(
					cicdDockerContainer.environmentVariables, 
					cicdDockerContainer.ports, 
					cicdDockerContainer.volumes, 
					cicdDockerContainer.network, 
					cicdDockerContainer.options
				)
		)
}

rule Assignment2Assignment {
	from
		cicdAssignment : CICD!Assignment
	to
		jenkinsAssignment : Jenkins!Assignment(
			key <- cicdAssignment.key,
			value <- cicdAssignment.value
		)
}

rule ScheduledTrigger2ScheduledTrigger {
	from
		cicdScheduledTrigger : CICD!ScheduledTrigger
	to
		jenkinsScheduledTrigger : Jenkins!ScheduledTrigger(
			cron <- cicdScheduledTrigger.crons->iterate(cron; acc: String = '' | acc + cron + '\\n')
		)
}

-- Helper

helper def : splitCommandAndArguments(commandString : String) : Sequence(String) =
	let splitString : Sequence(String) = commandString.split('\\s+')
	in 
	if splitString->size() > 1 then
		Sequence{splitString->first(), thisModule.joinStrings(splitString->subSequence(2, splitString->size()), ' ')}
	else if splitString->size() = 1 then
		Sequence{splitString, ''}
	else
		Sequence{'', ''}
	endif
	endif;
	
helper def : joinStrings(stringSequence : Sequence(String), sep : String) : String =
	stringSequence->iterate(string; joinedString : String = '' |
		if stringSequence->indexOf(string) = stringSequence->size() then
			joinedString.concat(string)
		else
			joinedString.concat(string).concat(sep)
		endif
	);

helper context CICD!Expression def : expression2String() : String = 'EXPRESSION';

helper context CICD!StringLiteral def : expression2String() : String = self.value;

helper context CICD!IntegerLiteral def : expression2String() : String = self.value.toString();

helper context CICD!DoubleLiteral def : expression2String() : String = self.value.toString();

helper context CICD!BooleanLiteral def : expression2String() : String = self.value.toString();

helper context CICD!Concat def : expression2String() : String =
	let exprStrings : Sequence(String) =
		self.expressions->collect(expr | expr.expression2String()) in
		exprStrings->iterate(exprString; joinedString: String = '' |
			joinedString.concat(exprString)
		);

helper context CICD!Variable def : expression2String() : String =
	'$'.concat(self.name);

helper context CICD!VariableContext def : expression2String() : String =
	self.context.toString();

helper context CICD!VariableDereference def : expression2String() : String =
	if self.variable.oclIsTypeOf(CICD!VariableContext) then
		if self.variable.context = #ENV then
			'$' + self.property
		else
			self.property
		endif
	else
		self.variable.expression2String() + '.' + self.property
	endif;

helper def : groupJobs(jobStreams : Sequence(CICD!Job), previous : Set(CICD!Job)) : Sequence(Sequence(CICD!Job)) =
	let next : Sequence(CICD!Job) = 
		jobStreams->iterate(jobStream; acc : Sequence(Sequence(CICD!Job)) = Sequence{} | 
			acc.append(jobStream.next->select(nextJob | previous.union(jobStreams).includesAll(nextJob.previous)))
		).flatten()->asSet()->asSequence()
	in 
	if next.isEmpty() then
		Sequence{jobStreams}
	else 
		thisModule.groupJobs(next, previous.union(jobStreams)).prepend(jobStreams)
	endif;

helper def : getDockerArguments(
	environmentVariables : Sequence(CICD!Assignment), 
	ports : Sequence(CICD!Expression),
	volumes : Sequence(CICD!Expression),
	network : CICD!Expression,
	options : String
) : String =
	if not environmentVariables->isEmpty() then
		' ' + thisModule.environmentVariables2String(environmentVariables)
	else
		''
	endif +
	if not ports->isEmpty() then
		' ' + thisModule.ports2String(ports)
	else
		''
	endif +
	if not volumes->isEmpty() then
		' ' + thisModule.volumes2String(volumes)
	else
		''
	endif +
	if not options.oclIsUndefined() and options <> '' then
		' ' + options
	else
		''
	endif;

helper def : environmentVariables2String(environmentVariables : Sequence(CICD!Assignment)) : String =
	environmentVariables->iterate(environmentVariable; acc: String = '' |
		acc + ' ' + thisModule.environmentVariable2String(environmentVariable)
	).toString().trim();

helper def : environmentVariable2String(environmentVariable : CICD!Assignment) : String =
	'-e ' + environmentVariable.key.name + '=\\\'' + environmentVariable.value.expression2String() + '\\\'';

helper def : ports2String(ports : Sequence(CICD!Expression)) : String =
	ports->iterate(port; acc : String = '' |
		acc + ' ' + '-p ' + port.expression2String()
	).toString().trim();

helper def : volumes2String(volumes : Sequence(CICD!Expression)) : String =
	volumes->iterate(volume; acc : String = '' |
		acc + ' ' + '-v ' + volume.expression2String()
	).toString().trim();
