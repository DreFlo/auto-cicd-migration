-- @path Jenkins=/d.fe.up.pt.cicd.jenkins.metamodel/model/Jenkins.ecore
-- @path CICD=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module cicd2jenkins;

create OUT : Jenkins from IN : CICD;

rule Pipeline2Pipeline {
	from
		cicdPipeline : CICD!Pipeline
	to
		jenkinsPipeline : Jenkins!Pipeline(
			begin <- 
				if cicdPipeline.jobStreams->size() = 1 then 
					thisModule.Job2Stage(cicdPipeline.jobStreams->first())
				else
					thisModule.JobSequence2Parallel(cicdPipeline.jobStreams)
				endif
		)
}

lazy rule Job2Stage {
	from
		job : CICD!Job
	using {
		nextJobs : Sequence(CICD!Job) = job.next;
	}
	to
		abstractStage : Jenkins!Stage(
			name <- job.id,
			steps <- job.steps,
			next <-
				if nextJobs->size() = 1 then 
					thisModule.Job2Stage(nextJobs->first())
				else if nextJobs->size() > 1 then
					thisModule.JobSequence2Parallel(nextJobs)
				else
					OclUndefined
				endif
				endif
		)
}

lazy rule JobSequence2Parallel {
	from
		jobSequence : Sequence(CICD!Job)
	using {
		nextJobs : Sequence(CICD!Job) = jobSequence->collect(job | job.next)->flatten()->asSet()->asSequence();
	}
	to
		abstractStage : Jenkins!Parallel(
			stages <- jobSequence->collect(job | thisModule.Job2Stage(job)),
			next <-
				if nextJobs->size() = 1 then 
					thisModule.Job2Stage(nextJobs->first())
				else if nextJobs->size() > 1 then
					thisModule.JobSequence2Parallel(nextJobs)
				else
					OclUndefined
				endif
				endif			
		)
}

abstract rule Step2AsbtractStep {
	from
		cicdStep : CICD!Step
	to
		jenkinsStep : Jenkins!AbstractStep
}

rule ConditionalStep2ConditionalStep extends Step2AsbtractStep {
	from
		cicdStep : CICD!ConditionalStep
	to
		jenkinsStep : Jenkins!ConditionalStep(
			thenRun <- cicdStep.thenRun,
			elseRun <- cicdStep.elseRun
		)
}

abstract rule NonConditionalStep2Step extends Step2AsbtractStep {
	from
		cicdStep : CICD!NonConditionalStep
	to
		jenkinsStep : Jenkins!Step
}

rule Command2Step extends NonConditionalStep2Step {
	from
		cicdStep : CICD!Command
	to
		jenkinsStep : Jenkins!Step(
			command <- cicdStep.program.expression2String()
		)
}

helper context CICD!Expression def : expression2String() : String = 'EXPRESSION';

helper context CICD!StringLiteral def : expression2String() : String = self.value;

