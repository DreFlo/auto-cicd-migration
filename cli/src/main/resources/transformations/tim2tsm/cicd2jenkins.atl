-- @path Jenkins=/d.fe.up.pt.cicd.jenkins.metamodel/model/Jenkins.ecore
-- @path CICD=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module cicd2jenkins;

create OUT : Jenkins from IN : CICD;

rule Pipeline2Pipeline {
	from
		cicdPipeline : CICD!Pipeline
	to
		jenkinsPipeline : Jenkins!Pipeline(
			stages <- thisModule.groupJobs(cicdPipeline.jobStreams, Set{})->collect(
						jobGroup | if jobGroup->size() = 1 then 
							if jobGroup->first().matrix.oclIsUndefined() then
								if jobGroup->first().oclIsTypeOf(CICD!ScriptJob) then
									thisModule.ScriptJob2StepStage(jobGroup->first())
								else if jobGroup->first().oclIsTypeOf(CICD!PipelineCallJob) then
									thisModule.PipelineCallJob2StepStage(jobGroup->first())
								else
									jobGroup->first()
								endif
								endif
							else
								thisModule.Job2MatrixStage(jobGroup->first())
							endif
						else
							thisModule.JobSequence2Parallel(jobGroup)
						endif
						),
			agent <- 
				if cicdPipeline.agent.oclIsUndefined() then 
					thisModule.CreateAnyAgent('') 
				else 
					cicdPipeline.agent 
				endif,
			environmentVariables <- cicdPipeline.environmentVariables,
			triggers <- cicdPipeline.triggers->select(trigger | trigger.oclIsTypeOf(CICD!ScheduledTrigger))
		)
	do {
		if (jenkinsPipeline.agent.oclIsTypeOf(Jenkins!NodeAgent) and not cicdPipeline.workingDirectory.oclIsUndefined()) {
			jenkinsPipeline.agent.customWorkspace <- cicdPipeline.workingDirectory;
		}
	}
}

lazy rule ScriptJob2StepStage {
	from
		job : CICD!ScriptJob
	to
		stage : Jenkins!StepStage(
			name <- job.id,
			agent <- job.agent,
			environmentVariables <- job.environmentVariables,
			steps <- job.steps,
			whens <- 
				if not job.ifCondition.oclIsUndefined() then
					Sequence{thisModule.Expression2WhenExpression(job.ifCondition)}
				else
					OclUndefined
				endif
		)
	do {
		if (stage.agent.oclIsTypeOf(Jenkins!NodeAgent) and not job.workingDirectory.oclIsUndefined()) {
			stage.agent.customWorkspace <- job.workingDirectory;
		}
	}
}

lazy rule PipelineCallJob2StepStage {
	from
		job : CICD!PipelineCallJob
	to
		stage : Jenkins!StepStage(
			name <- job.id,
			agent <- job.agent,
			environmentVariables <- job.environmentVariables,
			steps <- Sequence{thisModule.CreateBuildStep(job)},
			whens <- 
				if not job.ifCondition.oclIsUndefined() then
					Sequence{thisModule.Expression2WhenExpression(job.ifCondition)}
				else
					OclUndefined
				endif
		)
	do {
		if (stage.agent.oclIsTypeOf(Jenkins!NodeAgent) and not job.workingDirectory.oclIsUndefined()) {
			stage.agent.customWorkspace <- job.workingDirectory;
		}
	}
}

lazy rule CreateBuildStep {
	from
		job : CICD!PipelineCallJob
	to
		step : Jenkins!Step(
			command <- 'build',
			arguments <- Sequence{
				thisModule.CreateStepSingleArgument('job', Sequence{job.pipelinePath}),
				thisModule.CreateStepListArgument('parameters', job.args->collect(arg | thisModule.assignment2BuildStepParameterHelper(arg)))
			}
		)
}

lazy rule Assignment2StringBuildStepParameter {
	from
		assignment : CICD!Assignment
	to
		buildStepParameter : Jenkins!StringBuildStepParameter(
			name <- thisModule.String2StringLiteral(assignment.key.name),
			value <- thisModule.String2StringLiteral(assignment.value.value)
		)
}

lazy rule Assignment2CredentialsBuildStepParameter {
	from
		assignment : CICD!Assignment
	to
		buildStepParameter : Jenkins!CredentialsBuildStepParameter(
			name <- thisModule.String2StringLiteral(assignment.key.name),
			value <- thisModule.String2StringLiteral(assignment.value.expression2String())
		)
}

lazy rule Assignment2BooleanBuildStepParameter {
	from
		assignment : CICD!Assignment
	to
		buildStepParameter : Jenkins!BooleanBuildStepParameter(
			name <- thisModule.String2StringLiteral(assignment.key.name),
			value <- thisModule.Boolean2BooleanLiteral(assignment.value.value)
		)
}

lazy rule String2StringLiteral {
	from
		string : String
	to
		stringLiteral : Jenkins!StringLiteral(
			value <- string
		)
}

lazy rule Boolean2BooleanLiteral {
	from
		boolean : Boolean
	to
		booleanLiteral : Jenkins!BooleanLiteral(
			value <- boolean
		)
}

lazy rule Expression2WhenExpression {
	from
		expression : CICD!Expression
	to 
		when : Jenkins!WhenExpression (
			expression <- expression
		)
}

lazy rule Job2MatrixStage {
	from
		job : CICD!Job
	to
		stage : Jenkins!MatrixStage(
			name <- (job.id + '_matrix'),
			axes <- job.matrix.axes,
			includes <- job.matrix.includes,
			excludes <- job.matrix.excludes,
			failFast <- job.matrix.failFast,
			stages <- Sequence{
				if job.oclIsTypeOf(CICD!ScriptJob) then
					thisModule.ScriptJob2StepStage(job)
				else if job.oclIsTypeOf(CICD!PipelineCallJob) then
					thisModule.PipelineCallJob2StepStage(job)
				else
					job
				endif
				endif
			}
		)
}

rule MatrixAxis2MatrixAxis {
	from
		cicdAxis : CICD!MatrixAxis
	to
		jenkinsAxis : Jenkins!MatrixAxis(
			name <- cicdAxis.name,
			cells <- cicdAxis.cells
		)
}

rule MatrixCombination2MatrixCombination {
	from
		cicdCombination : CICD!MatrixCombination
	to
		jenkinsCombination : Jenkins!MatrixCombination(
			entries <- cicdCombination.combinationEntries
		)
}

lazy rule JobSequence2Parallel {
	from
		jobSequence : Sequence(CICD!Job)
	to
		abstractStage : Jenkins!ParallelNestedStage(
			name <- thisModule.joinStrings(jobSequence->collect(job | job.id), '||'),
			stages <- jobSequence->collect(job | 
				if job.oclIsTypeOf(CICD!ScriptJob) then
					thisModule.ScriptJob2StepStage(job)
				else if job.oclIsTypeOf(CICD!PipelineCallJob) then
					thisModule.PipelineCallJob2StepStage(job)
				else
					job
				endif
				endif
			)		
		)
}

rule ConditionalStep2ScriptedBlock {
	from
		cicdStep : CICD!ConditionalStep
	to
		jenkinsStep : Jenkins!ScriptedBlock(
			steps <- thisModule.ConditionalStep2ConditionalStep(cicdStep)
		)
}

lazy rule ConditionalStep2ConditionalStep {
	from
		cicdStep : CICD!ConditionalStep
	to
		jenkinsStep : Jenkins!ConditionalStep(
			ifCondition <- cicdStep.ifCondition,
			thenRun <- cicdStep.thenRun,
			elseRun <- cicdStep.elseRun
		)
}

rule Command2Step {
	from
		cicdStep : CICD!Command
	to
		jenkinsStep : Jenkins!Step(
			command <- 'sh',
			arguments <- thisModule.CreateStepSingleArgument('script', Sequence{cicdStep.program})
		)
}

lazy rule CreateStepSingleArgument {
	from
		string : String,
		expressions : Sequence(CICD!Expression)
	to
		assignment : Jenkins!StepSingleArgument(
			key <- thisModule.String2Variable(string),
			value <- expressions
		)
}

lazy rule CreateStepListArgument {
	from
		string : String,
		expressions : Sequence(CICD!Expression)
	to
		assignment : Jenkins!StepListArgument(
			key <- thisModule.String2Variable(string),
			value <- expressions
		)
}

lazy rule String2Variable {
	from
		string : String
	to
		variable : Jenkins!Variable(
			name <- string
		)
}

rule Plugin2Step {
	from
		cicdStep : CICD!Plugin
	to
		jenkinsStep : Jenkins!Step(
			command <- cicdStep.pluginName,
			arguments <- cicdStep.kwargs
		)
}

abstract rule Expression2Expression {
	from
		cicdExpression : CICD!Expression
	to
		jenkinsExpression : Jenkins!Expression
}

rule Concat2StringLiteral extends Expression2Expression {
	from
		cicdExpression : CICD!Concat
	to
		jenkinsExpression : Jenkins!StringLiteral(
			value <- cicdExpression.expression2String()
		)
}

abstract rule BinaryOp2BinaryOp extends Expression2Expression {
	from
		cicdExpression : CICD!BinaryOp
	to
		jenkinsExpression : Jenkins!BinaryOp(
			lhs <- cicdExpression.lhs,
			rhs <- cicdExpression.rhs
		)
}

abstract rule UnaryOp2UnaryOp extends Expression2Expression {
	from
		cicdExpression : CICD!UnaryOp
	to
		jenkinsExpression : Jenkins!UnaryOp(
			childExpr <- cicdExpression.rhs
		)
}

rule Negation2Negation extends UnaryOp2UnaryOp {
	from
		cicdExpression : CICD!Negation
	to
		jenkinsExpression : Jenkins!Negation
}

rule ComparisonOp2ComparisonOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!ComparisonOp
	to
		jenkinsExpression : Jenkins!ComparisonOp(
			op <- 
				if cicdExpression.op = #">" then
					#">"
				else if cicdExpression.op = #">=" then
					#">="
				else if cicdExpression.op = #"<" then
					#"<"
				else
					#"<="
				endif
				endif
				endif
		)
}

rule EqualityOp2EqualityOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!EqualityOp
	to
		jenkinsExpression : Jenkins!EqualityOp(
			op <- 
				if cicdExpression.op = #"==" then
					#"=="
				else
					#"!="
				endif
		)
}

abstract rule LogicalOp2LogicalOp extends BinaryOp2BinaryOp {
	from
		cicdExpression : CICD!LogicalOp
	to
		jenkinsExpression : Jenkins!LogicalOp
}

rule And2And extends LogicalOp2LogicalOp {
	from
		cicdExpression : CICD!And
	to
		jenkinsExpression : Jenkins!And
}

rule Or2Or extends LogicalOp2LogicalOp {
	from
		cicdExpression : CICD!Or
	to
		jenkinsExpression : Jenkins!Or
}

rule VariableDereference2VariableDereference extends Expression2Expression {
	from
		cicdExpression : CICD!VariableDereference
	to
		jenkinsExpression : Jenkins!VariableDereference(
			variable <- cicdExpression.variable,
			property <- cicdExpression.property
		)
}

abstract rule Value2Value extends Expression2Expression {
	from
		cicdExpression : CICD!Value
	to
		jenkinsExpression : Jenkins!Value
}

rule Variable2Variable extends Value2Value {
	from
		cicdExpression : CICD!Variable
	to
		jenkinsExpression : Jenkins!Variable(
			name <- cicdExpression.name
		)
}

rule VariableContext2JenkinsContext extends Value2Value {
	from
		cicdExpression : CICD!VariableContext
	to
		jenkinsExpression : Jenkins!JenkinsContext(
			name <- thisModule.variableContext2JenkinsContext(cicdExpression.context)
		)
}

abstract rule Literal2Literal extends Value2Value {
	from
		cicdExpression : CICD!Literal
	to
		jenkinsExpression : Jenkins!Literal		
}

rule StringLiteral2StringLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!StringLiteral
	to
		jenkinsExpression : Jenkins!StringLiteral(
			value <- cicdExpression.value
		)	
}

rule IntegerLiteral2IntegerLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!IntegerLiteral
	to
		jenkinsExpression : Jenkins!IntegerLiteral(
			value <- cicdExpression.value
		)	
}

rule DoubleLiteral2DoubleLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!DoubleLiteral
	to
		jenkinsExpression : Jenkins!DoubleLiteral(
			value <- cicdExpression.value
		)	
}

rule BooleanLiteral2BooleanLiteral extends Literal2Literal {
	from
		cicdExpression : CICD!BooleanLiteral
	to
		jenkinsExpression : Jenkins!BooleanLiteral(
			value <- cicdExpression.value
		)	
}

lazy rule CreateAnyAgent {
	from
		blank : String
	to
		agent : Jenkins!AnyAgent()
}

rule Agent2NodeAgent {
	from
		cicdAgent : CICD!Agent(
			cicdAgent.container.oclIsUndefined()
		)
	to
		jenkinsAgent : Jenkins!NodeAgent(
			labels <- cicdAgent.labels->first()
		)
}

rule Agent2DockerAgent {
	from
		cicdAgent : CICD!Agent(
			not cicdAgent.container.oclIsUndefined()
		)
	to
		jenkinsAgent : Jenkins!DockerAgent(
--- Conjunction
			labels <- cicdAgent.labels->first(),
			docker <- cicdAgent.container
		)
}

rule DockerContainer2DockerContainer {
	from
		cicdDockerContainer : CICD!DockerContainer
	to
		jenkinsDockerContainer : Jenkins!DockerContainer(
			image <- if not cicdDockerContainer.image.oclIsUndefined() then cicdDockerContainer.image.expression2String() else OclUndefined endif,
			label <- cicdDockerContainer.label,
			args <- 
				thisModule.getDockerArguments(
					cicdDockerContainer.environmentVariables, 
					cicdDockerContainer.ports, 
					cicdDockerContainer.volumes, 
					cicdDockerContainer.network, 
					cicdDockerContainer.options
				)
		)
}

rule Assignment2Assignment {
	from
		cicdAssignment : CICD!Assignment
	to
		jenkinsAssignment : Jenkins!Assignment(
			key <- cicdAssignment.key,
			value <- cicdAssignment.value
		)
}

rule ScheduledTrigger2ScheduledTrigger {
	from
		cicdScheduledTrigger : CICD!ScheduledTrigger
	to
		jenkinsScheduledTrigger : Jenkins!ScheduledTrigger(
			cron <- cicdScheduledTrigger.crons->iterate(cron; acc: String = '' | acc + cron + '\\n')
		)
}

-- Helper

helper def : splitCommandAndArguments(commandString : String) : Sequence(String) =
	let splitString : Sequence(String) = commandString.split('\\s+')
	in 
	if splitString->size() > 1 then
		Sequence{splitString->first(), thisModule.joinStrings(splitString->subSequence(2, splitString->size()), ' ')}
	else if splitString->size() = 1 then
		Sequence{splitString, ''}
	else
		Sequence{'', ''}
	endif
	endif;
	
helper def : joinStrings(stringSequence : Sequence(String), sep : String) : String =
	stringSequence->iterate(string; joinedString : String = '' |
		if stringSequence->indexOf(string) = stringSequence->size() then
			joinedString.concat(string)
		else
			joinedString.concat(string).concat(sep)
		endif
	);

helper context CICD!Expression def : expression2String() : String = 'EXPRESSION';

helper context CICD!StringLiteral def : expression2String() : String = self.value;

helper context CICD!IntegerLiteral def : expression2String() : String = self.value.toString();

helper context CICD!DoubleLiteral def : expression2String() : String = self.value.toString();

helper context CICD!BooleanLiteral def : expression2String() : String = self.value.toString();

helper context CICD!Concat def : expression2String() : String =
	let exprStrings : Sequence(String) =
		self.expressions->collect(expr | if expr.oclIsTypeOf(CICD!VariableDereference) then '${' + expr.expression2String() + '}' else expr.expression2String() endif) in
		exprStrings->iterate(exprString; joinedString: String = '' |
			joinedString.concat(exprString)
		);

helper context CICD!Variable def : expression2String() : String =
	'$'.concat(self.name);

helper context CICD!VariableContext def : expression2String() : String =
	thisModule.variableContext2JenkinsContext(self.context).toString();

helper context CICD!VariableDereference def : expression2String() : String =
	if not self.variable.oclIsUndefined() then self.variable.expression2String() else 'OclUndefined' endif + '.' + self.property;

helper def : groupJobs(jobStreams : Sequence(CICD!Job), previous : Set(CICD!Job)) : Sequence(Sequence(CICD!Job)) =
	let next : Sequence(CICD!Job) = 
		jobStreams->iterate(jobStream; acc : Sequence(Sequence(CICD!Job)) = Sequence{} | 
			acc.append(jobStream.next->select(nextJob | previous.union(jobStreams).includesAll(nextJob.previous)))
		).flatten()->asSet()->asSequence()
	in 
	if next.isEmpty() then
		Sequence{jobStreams}
	else 
		thisModule.groupJobs(next, previous.union(jobStreams)).prepend(jobStreams)
	endif;

helper def : getDockerArguments(
	environmentVariables : Sequence(CICD!Assignment), 
	ports : Sequence(CICD!Expression),
	volumes : Sequence(CICD!Expression),
	network : CICD!Expression,
	options : String
) : String =
	if not environmentVariables->isEmpty() then
		' ' + thisModule.environmentVariables2String(environmentVariables)
	else
		''
	endif +
	if not ports->isEmpty() then
		' ' + thisModule.ports2String(ports)
	else
		''
	endif +
	if not volumes->isEmpty() then
		' ' + thisModule.volumes2String(volumes)
	else
		''
	endif +
	if not options.oclIsUndefined() and options <> '' then
		' ' + options
	else
		''
	endif;

helper def : environmentVariables2String(environmentVariables : Sequence(CICD!Assignment)) : String =
	environmentVariables->iterate(environmentVariable; acc: String = '' |
		acc + ' ' + thisModule.environmentVariable2String(environmentVariable)
	).toString().trim();

helper def : environmentVariable2String(environmentVariable : CICD!Assignment) : String =
	'-e ' + environmentVariable.key.name + '=\\\'' + if not environmentVariable.value.oclIsUndefined() then environmentVariable.value.expression2String() else 'OclUndefined' endif + '\\\'';

helper def : ports2String(ports : Sequence(CICD!Expression)) : String =
	ports->iterate(port; acc : String = '' |
		acc + ' ' + '-p ' + port.expression2String()
	).toString().trim();

helper def : volumes2String(volumes : Sequence(CICD!Expression)) : String =
	volumes->iterate(volume; acc : String = '' |
		acc + ' ' + '-v ' + volume.expression2String()
	).toString().trim();

helper def : variableContext2JenkinsContext(variableContext : CICD!VARIABLE_CONTEXTS) : Jenkins!JENKINS_CONTEXTS =
	if variableContext = #ENV then
		#env
	else if variableContext = #PARAMS then
		#params
	else
		#""
	endif
	endif;

helper def : assignment2BuildStepParameterHelper(assignment : CICD!Assignment) : Jenkins!BuildStepParameter =
	if assignment.oclIsUndefined() then
		OclUndefined
	else if assignment.key.oclIsTypeOf(CICD!SecretVariable) then
		thisModule.Assignment2CredentialsBuildStepParameter(assignment)
	else if assignment.value.oclIsTypeOf(CICD!StringLiteral) or assignment.value.oclIsTypeOf(CICD!Concat) then
		thisModule.Assignment2StringBuildStepParameter(assignment)
	else if assignment.value.oclIsTypeOf(CICD!BooleanLiteral) then
		thisModule.Assignment2BooleanBuildStepParameter(assignment)
	else
		OclUndefined
	endif
	endif
	endif
	endif;
