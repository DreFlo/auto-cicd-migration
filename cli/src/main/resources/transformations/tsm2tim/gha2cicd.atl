-- @path GHA=/d.fe.up.pt.cicd.gha.metamodel/model/GHA.ecore
-- @path CICD=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module gha2cicd;
create OUT : CICD from IN : GHA;

rule Workflow2Pipeline {
	from
		workflow : GHA!Workflow
	to
		pipeline : CICD!Pipeline(
			name <- workflow.name.expression2String(),
			environmentVariables <- workflow.environmentVariables,
			inputs <- workflow.triggers->collect(
				trigger | trigger.oclIsKindOf(GHA!InputTrigger)
			)->collect(trigger | trigger.inputs),
			jobStreams <- thisModule.getJobStreamOrigins(workflow.jobs),
			triggers <- workflow.triggers->collect(trigger | not trigger.oclIsKindOf(GHA!InputTrigger)),
			workingDirectory <-
				if not workflow.defaults.oclIsUndefined() then
					workflow.defaults.workingDirectory.expression2String()
				else
					OclUndefined
				endif,
			concurrencyGroup <- workflow.concurrencyGroup,
			permissions <- workflow.permissions,
			shell <-
				if not workflow.defaults.oclIsUndefined() then
					workflow.defaults.shell.expression2String().getShell()
				else
					OclUndefined
				endif
		)
}

abstract rule Parameter2Parameter {
	from
		input : GHA!Parameter
	to
		output : CICD!Parameter(
			description <- input.description,
			id <- input.id
		)
}

rule Input2Input extends Parameter2Parameter {
	from
		input : GHA!Input
	to
		output : CICD!Input(
			choices <- input.options,
			defaultValue <- input.default,
			required <- input.isRequired,
			type <-
				if input.type = #STRING then
					#STRING
				else if input.type = #NUMBER then
					#NUMBER
				else if input.type = #BOOLEAN then
					#BOOLEAN
				else if input.type = #CHOICE then
					#CHOICE
				else
					#STRING
				endif
				endif
				endif
				endif
		)
}

rule Output2Output extends Parameter2Parameter {
	from
		input : GHA!Output
	to
		output : CICD!Output(
			value <- input.value
		)
}

abstract rule Job2Job {
	from
		ghaJob : GHA!Job
	to
		cicdJob : CICD!Job(
			id <- ghaJob.name,
			agent <- thisModule.GetAgentFromJob(ghaJob),
			ifCondition <- ghaJob.ifCondition,
			matrix <- ghaJob.strategy,
			next <- ghaJob.necessaryFor,
			workingDirectory <-
				if not ghaJob.defaults.oclIsUndefined() then
					ghaJob.defaults.workingDirectory.expression2String()
				else
					OclUndefined
				endif,
			allowFailure <- ghaJob.continueOnError.expression2Boolean(),
			permissions <- ghaJob.permissions,
			shell <-
				if not ghaJob.defaults.oclIsUndefined() then
					ghaJob.defaults.shell.expression2String().getShell()
				else
					OclUndefined
				endif,
			concurrencyGroup <- ghaJob.concurrencyGroup,
			name <- ghaJob.jobName.expression2String(),
			services <- ghaJob.services
		)
}

rule ScriptJob2ScriptJob extends Job2Job {
	from
		ghaJob : GHA!ScriptJob
	to
		cicdJob : CICD!ScriptJob(
			steps <- ghaJob.steps
		)
}

rule WorkflowCallJob2PipelineCallJob extends Job2Job {
	from
		ghaJob : GHA!WorkflowCallJob
	to
		cicdJob : CICD!PipelineCallJob(
			pipelinePath <- ghaJob.uses,
			args <- ghaJob.args.union(ghaJob.secrets)
		)
}

abstract rule AbstractStep2Step {
	from
		ghaStep : GHA!AbstractStep
	to
		cicdStep : CICD!Step
}

rule IfStep2ConditionalStep extends AbstractStep2Step {
	from
		ghaStep : GHA!IfStep
	to
		cicdStep : CICD!ConditionalStep(
			ifCondition <- ghaStep.ifCondition,
			thenRun <- ghaStep.thenRun
		)
}

abstract rule Step2NonConditionalStep extends AbstractStep2Step {
	from
		ghaStep : GHA!Step
	to
		cicdStep : CICD!NonConditionalStep(
			id <- ghaStep.id,
			timeoutMinutes <- 
				if not ghaStep.timeoutMinutes.oclIsUndefined() then
					ghaStep.timeoutMinutes.expression2String().stringToInt()
				else
					OclUndefined
				endif,
			environmentVariables <- ghaStep.environmentVariables,
			allowFailure <- ghaStep.continueOnError,
			name <- ghaStep.name.expression2String()
		)
}

rule Command2Command extends Step2NonConditionalStep {
	from
		ghaStep : GHA!Command
	to
		cicdStep : CICD!Command(
			program <- ghaStep.command
		)
}

rule Package2Plugin extends Step2NonConditionalStep {
	from
		ghaStep : GHA!Package(
			not ghaStep.uses.expression2String().startsWith('actions/cache') and
			not ghaStep.uses.expression2String().startsWith('actions/upload-artifact') and
			not ghaStep.uses.expression2String().startsWith('actions/download-artifact') and
			not ghaStep.uses.expression2String().startsWith('actions/checkout')
		)
	using {
		plugin : String = ghaStep.uses.expression2String().split('@')->first();
		version : String = ghaStep.uses.expression2String().split('@')->last();
	}
	to
		cicdStep : CICD!Plugin(
			pluginName <- plugin,
			version <- version,
			kwargs <- ghaStep.args
		)
}

rule Package2Cache extends Step2NonConditionalStep {
	from
		ghaStep : GHA!Package(
			ghaStep.uses.expression2String().startsWith('actions/cache')
		)
	to
		cicdStep : CICD!Cache(
			keys <- thisModule.getVariable(ghaStep.args, 'key'),
			paths <- thisModule.getVariable(ghaStep.args, 'path'),
			store <-
				if ghaStep.uses.expression2String().startsWith('actions/cache/restore') then
					#LOAD
				else if ghaStep.uses.expression2String().startsWith('actions/cache/save') then
					#STORE
				else
					#BOTH
				endif
				endif
		)
}

rule Package2Artifact extends Step2NonConditionalStep {
	from
		ghaStep : GHA!Package(
			ghaStep.uses.expression2String().startsWith('actions/upload-artifact') or
			ghaStep.uses.expression2String().startsWith('actions/download-artifact')
		)
	to
		cicdStep : CICD!Artifact(
			artifactName <- thisModule.getVariable(ghaStep.args, 'name'),
			includePaths <- thisModule.getVariable(ghaStep.args, 'path'),
			retentionTime <- thisModule.getVariable(ghaStep.args, 'retention-days'),
			store <- ghaStep.uses.expression2String().startsWith('actions/upload-artifact')
		)
}

rule Package2Checkout extends Step2NonConditionalStep {
	from
		ghaStep : GHA!Package(
			ghaStep.uses.expression2String().startsWith('actions/checkout')
		)
	to
		cicdStep : CICD!Checkout(
			path <- thisModule.getVariable(ghaStep.args, 'path')
		)
}

rule VariableAssignment2Assigment {
	from
		variableAssignment : GHA!VariableAssignment
	to
		assignment : CICD!Assignment (
			key <- variableAssignment.key.string2Variable(),
			value <- variableAssignment.value
		)
}

abstract rule Expression2Expression {
	from
		ghaExpression : GHA!Expression
	to
		cicdExpression : CICD!Expression
}

rule Concat2Concat extends Expression2Expression {
	from
		ghaExpression : GHA!Concat
	to
		cicdExpression : CICD!Concat(
			expressions <- ghaExpression.expressions	
		)
}

abstract rule BinaryOp2BinaryOp extends Expression2Expression {
	from
		ghaExpression : GHA!BinaryOp
	to
		cicdExpression : CICD!BinaryOp(
			lhs <- ghaExpression.lhs,
			rhs <- ghaExpression.rhs
		)
}

abstract rule LogicalOp2LogicalOp extends BinaryOp2BinaryOp {
	from
		ghaExpression : GHA!LogicalOp
	to
		cicdExpression : CICD!LogicalOp
}

rule And2And extends LogicalOp2LogicalOp {
	from
		ghaExpression : GHA!And
	to
		cicdExpression : CICD!And
}

rule Or2Or extends LogicalOp2LogicalOp {
	from
		ghaExpression : GHA!Or
	to
		cicdExpression : CICD!Or
}

rule Equality2EqualityOp extends BinaryOp2BinaryOp {
	from
		ghaExpression : GHA!Equality
	to
		cicdExpression : CICD!EqualityOp(
			op <-
				if ghaExpression.op = #"==" then
					#"=="
				else
					#"!="
				endif
		)
}

rule Comparison2ComparisonOp extends BinaryOp2BinaryOp {
	from
		ghaExpression : GHA!Comparison
	to
		cicdExpression : CICD!ComparisonOp(
			op <-
				if ghaExpression.op = #">" then
					#">"
				else if ghaExpression.op = #">=" then
					#">="
				else if ghaExpression.op = #"<" then
					#"<"
				else
					#"<="
				endif
				endif
				endif
		)
}

abstract rule Value2Value extends Expression2Expression {
	from
		ghaExpression : GHA!Value
	to
		cicdExpression : CICD!Value
}

abstract rule Literal2Literal extends Value2Value {
	from
		ghaExpression : GHA!Literal
	to
		cicdExpression : CICD!Literal
}

rule StringLiteral2StringLiteral extends Literal2Literal {
	from
		ghaExpression : GHA!StringLiteral
	to
		cicdExpression : CICD!StringLiteral(
			value <- ghaExpression.value	
		)
}

rule IntegerLiteral2IntegerLiteral extends Literal2Literal {
	from
		ghaExpression : GHA!IntegerLiteral
	to
		cicdExpression : CICD!IntegerLiteral(
			value <- ghaExpression.value	
		)
}

rule DoubleLiteral2DoubleLiteral extends Literal2Literal {
	from
		ghaExpression : GHA!DoubleLiteral
	to
		cicdExpression : CICD!DoubleLiteral(
			value <- ghaExpression.value	
		)
}

rule BooleanLiteral2BooleanLiteral extends Literal2Literal {
	from
		ghaExpression : GHA!BooleanLiteral
	to
		cicdExpression : CICD!BooleanLiteral(
			value <- ghaExpression.value	
		)
}

abstract rule UnaryOp2UnaryOp extends Expression2Expression {
	from
		ghaExpression : GHA!UnaryOp
	to
		cicdExpression : CICD!UnaryOp(
			rhs <- ghaExpression.childExpr
		)
}

rule Not2Negation extends Expression2Expression {
	from
		ghaExpression : GHA!Not
	to
		cicdExpression : CICD!Negation
}

rule VariableDereference2VariableDereference extends Expression2Expression {
	from
		ghaExpression : GHA!VariableDereference
	to
		cicdExpression : CICD!VariableDereference(
			variable <- ghaExpression.variable,
			property <- ghaExpression.property
		)
}

rule GitHubContext2VariableContext extends Value2Value {
	from
		ghaExpression : GHA!GitHubContext
	to
		cicdExpression : CICD!VariableContext(
			context <-
				if ghaExpression.context = #env then
					#ENV
				else if ghaExpression.context = #inputs then
					#PARAMS
				else
					#""
				endif
				endif
		)
}

rule Container2DockerContainer {
	from
		container : GHA!Container
	to
		dockerContainer : CICD!DockerContainer(
			image <- container.image,
			environmentVariables <- container.environmentVariables,
			ports <- container.ports,
			volumes <- container.volumes,
			registryUsername <- container.username,
			registryPassword <- container.password,
			options <- container.options.expression2String()
		)
}

rule Service2DockerContainer {
	from
		service : GHA!Service
	using {
		container : GHA!Container = service.value;
	}
	to
		dockerContainer : CICD!DockerContainer(
			label <- service.key,
			image <- container.image,
			environmentVariables <- container.environmentVariables,
			ports <- container.ports,
			volumes <- container.volumes,
			registryUsername <- container.username,
			registryPassword <- container.password,
			options <- container.options.expression2String()
		)
}

abstract rule Trigger2Trigger {
	from
		ghaTrigger : GHA!Trigger
	to
		cicdTrigger : CICD!Trigger
}

rule ScheduledTrigger2ScheduledTrigger extends Trigger2Trigger {
	from
		ghaTrigger : GHA!ScheduleTrigger
	to
		cicdTrigger : CICD!ScheduledTrigger(
			crons <- ghaTrigger.crons->collect(cron | cron.expression2String())
		)
}

rule PushTrigger2PushTrigger extends Trigger2Trigger {
	from
		ghaTrigger : GHA!PushTrigger
	to
		cicdTrigger : CICD!PushTrigger(
			tagGlobs <- 
				if not ghaTrigger.ignoreSpecifiedTags then
					ghaTrigger.tags->collect(tag | tag.expression2String())
				else
					Sequence{'*'}->union(ghaTrigger.tags->collect(tag | tag.negationString()))
				endif,
			branchGlobs <- 
				if not ghaTrigger.ignoreSpecifiedBranches then
					ghaTrigger.branches->collect(branch | branch.expression2String())
				else
					Sequence{'*'}->union(ghaTrigger.branches->collect(branch | branch.negationString()))
				endif
		)		
}

rule PullRequestTrigger2PullRequestTrigger extends Trigger2Trigger {
	from
		ghaTrigger : GHA!PullRequestTrigger
	to
		cicdTrigger : CICD!PullRequestTrigger(
			branchGlobs <- 
				if not ghaTrigger.ignoreSpecifiedBranches then
					ghaTrigger.branches->collect(branch | branch.expression2String())
				else
					Sequence{'*'}->union(ghaTrigger.branches->collect(branch | branch.negationString()))
				endif
		)	
}

rule Matrix2Matrix {
	from
		ghaMatrix : GHA!Matrix
	to
		cicdMatrix : CICD!Matrix(
			axes <- ghaMatrix.axes,
			includes <- ghaMatrix.includes,
			excludes <- ghaMatrix.excludes,
			failFast <- ghaMatrix.failFast.expression2Boolean()
		)
}

rule MatrixAxis2MatrixAxis {
	from
		ghaAxis : GHA!MatrixAxis
	to
		cicdAxis : CICD!MatrixAxis(
			name <- ghaAxis.name,
			cells <- ghaAxis.cells
		)
}

rule MatrixCombination2MatrixCombination {
	from
		ghaCombination : GHA!MatrixCombination
	to
		cicdCombination : CICD!MatrixCombination(
			combinationEntries <- ghaCombination.entries
		)
}

rule ConcurrencyGroup2ConcurrencyGroup {
	from
		ghaGroup : GHA!ConcurrencyGroup
	to
		cicdGroup : CICD!ConcurrencyGroup(
			groupId <- ghaGroup.name,
			cancelInProgress <- ghaGroup.cancelInProgress.expression2Boolean()
		)
}

rule Permission2Permission {
	from
		ghaPermission : GHA!Permission
	to
		cicdPermission : CICD!Permission(
			key <- ghaPermission.key.toString(),
			value <-
				if ghaPermission.value = #read then
					#READ
				else if ghaPermission.value = #write then
					#WRITE
				else
					#NONE
				endif
				endif
		)
}

-- Lazy Rules

lazy rule GetAgentFromJob {
	from
		job : GHA!Job
	to
		agent : CICD!Agent(
			labels <- job.agent.labels,
			container <- job.container
		)
}

lazy rule NegateExpression {
	from
		expression : GHA!Expression
	to
		negatedExpression : CICD!Negation(
			rhs <- expression
		)
}

lazy rule String2StringLiteral {
	from
		string : String
	to
		stringLiteral : CICD!StringLiteral(
			value <- string
		)
}

-- Helpers

helper def : getJobStreamOrigins(jobs : Sequence(GHA!Job)) : Sequence(GHA!Job) = 
	jobs->select(job | job.dependsOn->isEmpty());

helper context GHA!Expression def : expression2String() : String = 'EXPRESSION';

helper context GHA!Literal def : expression2String() : String = 'LITERAL';

helper context GHA!StringLiteral def : expression2String() : String = self.value;

helper context GHA!IntegerLiteral def : expression2String() : String = self.value.toString();

helper context GHA!DoubleLiteral def : expression2String() : String = self.value.toString();

helper context GHA!BooleanLiteral def : expression2String() : String = self.value.toString();

helper context OclAny def : expression2String() : String = OclUndefined;

helper context GHA!Concat def : expression2String() : String =
	let exprStrings : Sequence(String) =
		self.expressions->collect(expr | expr.expression2String()) in
		exprStrings->iterate(exprString; joinedString: String = '' |
			joinedString.concat(exprString)
		);

helper context GHA!Not def : expression2String() : String = 
	if self.childExpr.oclIsKindOf(GHA!Value) then
		'!' + self.childExpr.expression2String()
	else
		'!(' + self.childExpr.expression2String() + ')'
	endif;

helper context GHA!Expression def : negationString() : String =
	if self.oclIsKindOf(GHA!Value) then
		'!' + self.expression2String()
	else
		'!(' + self.expression2String() + ')'
	endif;

helper context GHA!Expression def : expression2Boolean() : Boolean = false;

helper context GHA!BooleanLiteral def : expression2Boolean() : Boolean = self.value;

helper context GHA!IntegerLiteral def : expression2Boolean() : Boolean =
	if self.value = 0 then
		false
	else
		true
	endif;

helper context GHA!DoubleLiteral def : expression2Boolean() : Boolean =
	if self.value = 0.0 then
		false
	else
		true
	endif;

helper context GHA!StringLiteral def : expression2Boolean() : Boolean =
	if self.value = 'false' then
		false
	else
		true
	endif;

helper context OclAny def : expression2Boolean() : String = OclUndefined;

helper context String def : string2Variable() : CICD!EnvironmentVariable =
	let environmentVariable : CICD!Variable = CICD!Variable.newInstance() in
		environmentVariable.refSetValue('name', self);

helper context String def : stringToInt() : Integer = Integer.parseInt(self);

helper context String def : getShell() : CICD!SHELL_TYPE = #BASH;

helper def : getVariable(map : Sequence(GHA!VariableAssignment), key : String) : GHA!Expression =
	let matching : Sequence(GHA!VariableAssignment) = 
		map->select(assignment | assignment.key = key)
	in
	if matching->size() >= 1 then
		matching->first().value
	else
		OclUndefined
	endif;