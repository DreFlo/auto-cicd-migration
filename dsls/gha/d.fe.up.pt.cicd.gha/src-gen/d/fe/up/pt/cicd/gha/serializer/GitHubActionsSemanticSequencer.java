/*
 * generated by Xtext 2.33.0
 */
package d.fe.up.pt.cicd.gha.serializer;

import GHA.Expressions.BinaryOperators.BinaryOperatorsPackage;
import GHA.Expressions.BinaryOperators.ComparisonOperators.Comparison;
import GHA.Expressions.BinaryOperators.ComparisonOperators.ComparisonOperatorsPackage;
import GHA.Expressions.BinaryOperators.Concat;
import GHA.Expressions.BinaryOperators.EqualityOperators.Equality;
import GHA.Expressions.BinaryOperators.EqualityOperators.EqualityOperatorsPackage;
import GHA.Expressions.BinaryOperators.LogicalOperators.And;
import GHA.Expressions.BinaryOperators.LogicalOperators.LogicalOperatorsPackage;
import GHA.Expressions.BinaryOperators.LogicalOperators.Or;
import GHA.Expressions.BuiltInFunctions.BuiltInFunctionsPackage;
import GHA.Expressions.BuiltInFunctions.Contains;
import GHA.Expressions.BuiltInFunctions.EndsWith;
import GHA.Expressions.BuiltInFunctions.Format;
import GHA.Expressions.BuiltInFunctions.FromJSON;
import GHA.Expressions.BuiltInFunctions.HashFiles;
import GHA.Expressions.BuiltInFunctions.Join;
import GHA.Expressions.BuiltInFunctions.StartsWith;
import GHA.Expressions.BuiltInFunctions.StatusCheckFunctions.Always;
import GHA.Expressions.BuiltInFunctions.StatusCheckFunctions.Cancelled;
import GHA.Expressions.BuiltInFunctions.StatusCheckFunctions.Failure;
import GHA.Expressions.BuiltInFunctions.StatusCheckFunctions.StatusCheckFunctionsPackage;
import GHA.Expressions.BuiltInFunctions.StatusCheckFunctions.Success;
import GHA.Expressions.BuiltInFunctions.ToJSON;
import GHA.Expressions.ExpressionsPackage;
import GHA.Expressions.UnaryOperators.Not;
import GHA.Expressions.UnaryOperators.UnaryOperatorsPackage;
import GHA.Expressions.Values.Literals.BooleanLiteral;
import GHA.Expressions.Values.Literals.DoubleLiteral;
import GHA.Expressions.Values.Literals.IntegerLiteral;
import GHA.Expressions.Values.Literals.LiteralsPackage;
import GHA.Expressions.Values.Literals.StringLiteral;
import GHA.Expressions.Values.Variables.GitHubContext;
import GHA.Expressions.Values.Variables.Variable;
import GHA.Expressions.Values.Variables.VariableDereference;
import GHA.Expressions.Values.Variables.VariablesPackage;
import GHA.GHAPackage;
import GHA.Jobs.Agent;
import GHA.Jobs.Container;
import GHA.Jobs.JobsPackage;
import GHA.Jobs.Matrices.MatricesPackage;
import GHA.Jobs.Matrices.Matrix;
import GHA.Jobs.Matrices.MatrixAxis;
import GHA.Jobs.Matrices.MatrixCombination;
import GHA.Jobs.ReuseWorkflowJob;
import GHA.Jobs.ScriptJob;
import GHA.Jobs.StagingEnvironment;
import GHA.Jobs.Steps.Command;
import GHA.Jobs.Steps.StepsPackage;
import GHA.Options.ConcurrencyGroup;
import GHA.Options.Defaults;
import GHA.Options.OptionsPackage;
import GHA.Triggers.Parameters.Input;
import GHA.Triggers.Parameters.Output;
import GHA.Triggers.Parameters.ParametersPackage;
import GHA.Triggers.Parameters.Secret;
import GHA.Triggers.PullRequestTrigger;
import GHA.Triggers.PushTrigger;
import GHA.Triggers.ScheduleTrigger;
import GHA.Triggers.StandardEventTrigger;
import GHA.Triggers.TriggersPackage;
import GHA.Triggers.WorkflowCallTrigger;
import GHA.Triggers.WorkflowDispatchTrigger;
import GHA.Triggers.WorkflowRunTrigger;
import GHA.Workflow;
import com.google.inject.Inject;
import d.fe.up.pt.cicd.gha.services.GitHubActionsGrammarAccess;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GitHubActionsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GitHubActionsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BinaryOperatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BinaryOperatorsPackage.CONCAT:
				sequence_Concat(context, (Concat) semanticObject); 
				return; 
			}
		else if (epackage == BuiltInFunctionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BuiltInFunctionsPackage.CONTAINS:
				sequence_Contains(context, (Contains) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.ENDS_WITH:
				sequence_EndsWith(context, (EndsWith) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.FORMAT:
				sequence_Format(context, (Format) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.FROM_JSON:
				sequence_FromJSON(context, (FromJSON) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.HASH_FILES:
				sequence_HashFiles(context, (HashFiles) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.STARTS_WITH:
				sequence_StartsWith(context, (StartsWith) semanticObject); 
				return; 
			case BuiltInFunctionsPackage.TO_JSON:
				sequence_ToJSON(context, (ToJSON) semanticObject); 
				return; 
			}
		else if (epackage == ComparisonOperatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ComparisonOperatorsPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			}
		else if (epackage == EqualityOperatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EqualityOperatorsPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.VARIABLE_ASSIGNMENT:
				sequence_VariableAssignment(context, (Map.Entry) semanticObject); 
				return; 
			}
		else if (epackage == GHAPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GHAPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		else if (epackage == JobsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JobsPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case JobsPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case JobsPackage.REUSE_WORKFLOW_JOB:
				sequence_ReuseWorkflowJob(context, (ReuseWorkflowJob) semanticObject); 
				return; 
			case JobsPackage.SCRIPT_JOB:
				sequence_ScriptJob(context, (ScriptJob) semanticObject); 
				return; 
			case JobsPackage.SERVICE:
				sequence_Service(context, (Map.Entry) semanticObject); 
				return; 
			case JobsPackage.STAGING_ENVIRONMENT:
				sequence_StagingEnvironment(context, (StagingEnvironment) semanticObject); 
				return; 
			}
		else if (epackage == LiteralsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LiteralsPackage.BOOLEAN_LITERAL:
				sequence_Atomic(context, (BooleanLiteral) semanticObject); 
				return; 
			case LiteralsPackage.DOUBLE_LITERAL:
				sequence_Atomic(context, (DoubleLiteral) semanticObject); 
				return; 
			case LiteralsPackage.INTEGER_LITERAL:
				sequence_Atomic(context, (IntegerLiteral) semanticObject); 
				return; 
			case LiteralsPackage.STRING_LITERAL:
				if (rule == grammarAccess.getBracketedExpressionRule()
						|| rule == grammarAccess.getInsideBracketsExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLhsAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0()
						|| rule == grammarAccess.getUnaryOpRule()
						|| rule == grammarAccess.getBlankRule()
						|| rule == grammarAccess.getVariableDereferenceRule()
						|| rule == grammarAccess.getDotDereferenceRule()
						|| action == grammarAccess.getDotDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getArrayDereferenceRule()
						|| action == grammarAccess.getArrayDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConcatRule()
						|| action == grammarAccess.getConcatAccess().getConcatLhsAction_1_0()
						|| rule == grammarAccess.getConcatExpressionRule()) {
					sequence_Atomic_UnbracketedString(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnbracketedLiteralRule()
						|| rule == grammarAccess.getUnbracketedStringRule()) {
					sequence_UnbracketedString(context, (StringLiteral) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == LogicalOperatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LogicalOperatorsPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case LogicalOperatorsPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			}
		else if (epackage == MatricesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MatricesPackage.MATRIX:
				sequence_Strategy(context, (Matrix) semanticObject); 
				return; 
			case MatricesPackage.MATRIX_AXIS:
				sequence_MatrixAxis(context, (MatrixAxis) semanticObject); 
				return; 
			case MatricesPackage.MATRIX_COMBINATION:
				sequence_MatrixCombination(context, (MatrixCombination) semanticObject); 
				return; 
			}
		else if (epackage == OptionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OptionsPackage.CONCURRENCY_GROUP:
				sequence_ConcurrencyGroup(context, (ConcurrencyGroup) semanticObject); 
				return; 
			case OptionsPackage.DEFAULTS:
				sequence_Defaults(context, (Defaults) semanticObject); 
				return; 
			case OptionsPackage.PERMISSION:
				sequence_Permission(context, (Map.Entry) semanticObject); 
				return; 
			}
		else if (epackage == ParametersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ParametersPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case ParametersPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case ParametersPackage.SECRET:
				sequence_Secret(context, (Secret) semanticObject); 
				return; 
			}
		else if (epackage == StatusCheckFunctionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatusCheckFunctionsPackage.ALWAYS:
				sequence_Always(context, (Always) semanticObject); 
				return; 
			case StatusCheckFunctionsPackage.CANCELLED:
				sequence_Cancelled(context, (Cancelled) semanticObject); 
				return; 
			case StatusCheckFunctionsPackage.FAILURE:
				sequence_Failure(context, (Failure) semanticObject); 
				return; 
			case StatusCheckFunctionsPackage.SUCCESS:
				sequence_Success(context, (Success) semanticObject); 
				return; 
			}
		else if (epackage == StepsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StepsPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case StepsPackage.PACKAGE:
				sequence_Package(context, (GHA.Jobs.Steps.Package) semanticObject); 
				return; 
			}
		else if (epackage == TriggersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TriggersPackage.PULL_REQUEST_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedPullRequestTriggerRule()) {
					sequence_OptionedPullRequestTrigger(context, (PullRequestTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimplePullRequestTriggerRule()) {
					sequence_SimplePullRequestTrigger(context, (PullRequestTrigger) semanticObject); 
					return; 
				}
				else break;
			case TriggersPackage.PUSH_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedPushTriggerRule()) {
					sequence_OptionedPushTrigger(context, (PushTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimplePushTriggerTriggerRule()) {
					sequence_SimplePushTriggerTrigger(context, (PushTrigger) semanticObject); 
					return; 
				}
				else break;
			case TriggersPackage.SCHEDULE_TRIGGER:
				sequence_OptionedScheduleTrigger(context, (ScheduleTrigger) semanticObject); 
				return; 
			case TriggersPackage.STANDARD_EVENT_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedStandardEventTriggerRule()) {
					sequence_OptionedStandardEventTrigger(context, (StandardEventTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleStandardEventTriggerRule()) {
					sequence_SimpleStandardEventTrigger(context, (StandardEventTrigger) semanticObject); 
					return; 
				}
				else break;
			case TriggersPackage.WORKFLOW_CALL_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedWorkflowCallTriggerRule()) {
					sequence_OptionedWorkflowCallTrigger(context, (WorkflowCallTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleWorkflowCallTriggerRule()) {
					sequence_SimpleWorkflowCallTrigger(context, (WorkflowCallTrigger) semanticObject); 
					return; 
				}
				else break;
			case TriggersPackage.WORKFLOW_DISPATCH_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedWorkflowDispatchTriggerRule()) {
					sequence_OptionedWorkflowDispatchTrigger(context, (WorkflowDispatchTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleWorkflowDispatchTriggerRule()) {
					sequence_SimpleWorkflowDispatchTrigger(context, (WorkflowDispatchTrigger) semanticObject); 
					return; 
				}
				else break;
			case TriggersPackage.WORKFLOW_RUN_TRIGGER:
				sequence_OptionedWorkflowRunTrigger(context, (WorkflowRunTrigger) semanticObject); 
				return; 
			}
		else if (epackage == UnaryOperatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UnaryOperatorsPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			}
		else if (epackage == VariablesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VariablesPackage.GIT_HUB_CONTEXT:
				sequence_Atomic(context, (GitHubContext) semanticObject); 
				return; 
			case VariablesPackage.VARIABLE:
				sequence_Atomic(context, (Variable) semanticObject); 
				return; 
			case VariablesPackage.VARIABLE_DEREFERENCE:
				sequence_ArrayDereference_DotDereference(context, (VariableDereference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (
	 *         labels+=Expression | 
	 *         (labels+=Expression labels+=Expression*) | 
	 *         labels+=Expression+ | 
	 *         ((labels+=Expression | labels+=Expression | group=Expression)? (labels+=Expression labels+=Expression*)?)+
	 *     )?
	 * </pre>
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Always
	 *     Expression returns Always
	 *     Concat returns Always
	 *     Concat.Concat_1_0 returns Always
	 *     ConcatExpression returns Always
	 *     BracketedExpression returns Always
	 *     InsideBracketsExpression returns Always
	 *     Or returns Always
	 *     Or.Or_1_0 returns Always
	 *     And returns Always
	 *     And.And_1_0 returns Always
	 *     Equality returns Always
	 *     Equality.Equality_1_0 returns Always
	 *     Comparison returns Always
	 *     Comparison.Comparison_1_0 returns Always
	 *     UnaryOp returns Always
	 *     Blank returns Always
	 *     VariableDereference returns Always
	 *     DotDereference returns Always
	 *     DotDereference.VariableDereference_1_0 returns Always
	 *     ArrayDereference returns Always
	 *     ArrayDereference.VariableDereference_1_0 returns Always
	 *     Primary returns Always
	 *     CallExpression returns Always
	 *     Always returns Always
	 *
	 * Constraint:
	 *     {Always}
	 * </pre>
	 */
	protected void sequence_Always(ISerializationContext context, Always semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns And
	 *     Expression returns And
	 *     Concat returns And
	 *     Concat.Concat_1_0 returns And
	 *     ConcatExpression returns And
	 *     BracketedExpression returns And
	 *     InsideBracketsExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     UnaryOp returns And
	 *     Blank returns And
	 *     VariableDereference returns And
	 *     DotDereference returns And
	 *     DotDereference.VariableDereference_1_0 returns And
	 *     ArrayDereference returns And
	 *     ArrayDereference.VariableDereference_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (lhs=And_And_1_0 rhs=Equality)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAndAccess().getRhsEqualityParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns VariableDereference
	 *     Expression returns VariableDereference
	 *     Concat returns VariableDereference
	 *     Concat.Concat_1_0 returns VariableDereference
	 *     ConcatExpression returns VariableDereference
	 *     BracketedExpression returns VariableDereference
	 *     InsideBracketsExpression returns VariableDereference
	 *     Or returns VariableDereference
	 *     Or.Or_1_0 returns VariableDereference
	 *     And returns VariableDereference
	 *     And.And_1_0 returns VariableDereference
	 *     Equality returns VariableDereference
	 *     Equality.Equality_1_0 returns VariableDereference
	 *     Comparison returns VariableDereference
	 *     Comparison.Comparison_1_0 returns VariableDereference
	 *     UnaryOp returns VariableDereference
	 *     Blank returns VariableDereference
	 *     VariableDereference returns VariableDereference
	 *     DotDereference returns VariableDereference
	 *     DotDereference.VariableDereference_1_0 returns VariableDereference
	 *     ArrayDereference returns VariableDereference
	 *     ArrayDereference.VariableDereference_1_0 returns VariableDereference
	 *     Primary returns VariableDereference
	 *
	 * Constraint:
	 *     ((variable=DotDereference_VariableDereference_1_0 property=ID) | (variable=ArrayDereference_VariableDereference_1_0 property=ID))
	 * </pre>
	 */
	protected void sequence_ArrayDereference_DotDereference(ISerializationContext context, VariableDereference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     Concat returns BooleanLiteral
	 *     Concat.Concat_1_0 returns BooleanLiteral
	 *     ConcatExpression returns BooleanLiteral
	 *     BracketedExpression returns BooleanLiteral
	 *     InsideBracketsExpression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Equality returns BooleanLiteral
	 *     Equality.Equality_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.Comparison_1_0 returns BooleanLiteral
	 *     UnaryOp returns BooleanLiteral
	 *     Blank returns BooleanLiteral
	 *     VariableDereference returns BooleanLiteral
	 *     DotDereference returns BooleanLiteral
	 *     DotDereference.VariableDereference_1_0 returns BooleanLiteral
	 *     ArrayDereference returns BooleanLiteral
	 *     ArrayDereference.VariableDereference_1_0 returns BooleanLiteral
	 *     Primary returns BooleanLiteral
	 *     Atomic returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LiteralsPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LiteralsPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_4_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns DoubleLiteral
	 *     Expression returns DoubleLiteral
	 *     Concat returns DoubleLiteral
	 *     Concat.Concat_1_0 returns DoubleLiteral
	 *     ConcatExpression returns DoubleLiteral
	 *     BracketedExpression returns DoubleLiteral
	 *     InsideBracketsExpression returns DoubleLiteral
	 *     Or returns DoubleLiteral
	 *     Or.Or_1_0 returns DoubleLiteral
	 *     And returns DoubleLiteral
	 *     And.And_1_0 returns DoubleLiteral
	 *     Equality returns DoubleLiteral
	 *     Equality.Equality_1_0 returns DoubleLiteral
	 *     Comparison returns DoubleLiteral
	 *     Comparison.Comparison_1_0 returns DoubleLiteral
	 *     UnaryOp returns DoubleLiteral
	 *     Blank returns DoubleLiteral
	 *     VariableDereference returns DoubleLiteral
	 *     DotDereference returns DoubleLiteral
	 *     DotDereference.VariableDereference_1_0 returns DoubleLiteral
	 *     ArrayDereference returns DoubleLiteral
	 *     ArrayDereference.VariableDereference_1_0 returns DoubleLiteral
	 *     Primary returns DoubleLiteral
	 *     Atomic returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LiteralsPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LiteralsPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns GitHubContext
	 *     Expression returns GitHubContext
	 *     Concat returns GitHubContext
	 *     Concat.Concat_1_0 returns GitHubContext
	 *     ConcatExpression returns GitHubContext
	 *     BracketedExpression returns GitHubContext
	 *     InsideBracketsExpression returns GitHubContext
	 *     Or returns GitHubContext
	 *     Or.Or_1_0 returns GitHubContext
	 *     And returns GitHubContext
	 *     And.And_1_0 returns GitHubContext
	 *     Equality returns GitHubContext
	 *     Equality.Equality_1_0 returns GitHubContext
	 *     Comparison returns GitHubContext
	 *     Comparison.Comparison_1_0 returns GitHubContext
	 *     UnaryOp returns GitHubContext
	 *     Blank returns GitHubContext
	 *     VariableDereference returns GitHubContext
	 *     DotDereference returns GitHubContext
	 *     DotDereference.VariableDereference_1_0 returns GitHubContext
	 *     ArrayDereference returns GitHubContext
	 *     ArrayDereference.VariableDereference_1_0 returns GitHubContext
	 *     Primary returns GitHubContext
	 *     Atomic returns GitHubContext
	 *
	 * Constraint:
	 *     context=CONTEXT
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, GitHubContext semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VariablesPackage.Literals.GIT_HUB_CONTEXT__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VariablesPackage.Literals.GIT_HUB_CONTEXT__CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getContextCONTEXTEnumRuleCall_0_1_0(), semanticObject.getContext());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns IntegerLiteral
	 *     Expression returns IntegerLiteral
	 *     Concat returns IntegerLiteral
	 *     Concat.Concat_1_0 returns IntegerLiteral
	 *     ConcatExpression returns IntegerLiteral
	 *     BracketedExpression returns IntegerLiteral
	 *     InsideBracketsExpression returns IntegerLiteral
	 *     Or returns IntegerLiteral
	 *     Or.Or_1_0 returns IntegerLiteral
	 *     And returns IntegerLiteral
	 *     And.And_1_0 returns IntegerLiteral
	 *     Equality returns IntegerLiteral
	 *     Equality.Equality_1_0 returns IntegerLiteral
	 *     Comparison returns IntegerLiteral
	 *     Comparison.Comparison_1_0 returns IntegerLiteral
	 *     UnaryOp returns IntegerLiteral
	 *     Blank returns IntegerLiteral
	 *     VariableDereference returns IntegerLiteral
	 *     DotDereference returns IntegerLiteral
	 *     DotDereference.VariableDereference_1_0 returns IntegerLiteral
	 *     ArrayDereference returns IntegerLiteral
	 *     ArrayDereference.VariableDereference_1_0 returns IntegerLiteral
	 *     Primary returns IntegerLiteral
	 *     Atomic returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LiteralsPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LiteralsPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BracketedExpression returns StringLiteral
	 *     InsideBracketsExpression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     UnaryOp returns StringLiteral
	 *     Blank returns StringLiteral
	 *     VariableDereference returns StringLiteral
	 *     DotDereference returns StringLiteral
	 *     DotDereference.VariableDereference_1_0 returns StringLiteral
	 *     ArrayDereference returns StringLiteral
	 *     ArrayDereference.VariableDereference_1_0 returns StringLiteral
	 *     Primary returns StringLiteral
	 *     Atomic returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LiteralsPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LiteralsPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Concat returns StringLiteral
	 *     Concat.Concat_1_0 returns StringLiteral
	 *     ConcatExpression returns StringLiteral
	 *
	 * Constraint:
	 *     (value=YAML_STRING | value=STRING)
	 * </pre>
	 */
	protected void sequence_Atomic_UnbracketedString(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Variable
	 *     Expression returns Variable
	 *     Concat returns Variable
	 *     Concat.Concat_1_0 returns Variable
	 *     ConcatExpression returns Variable
	 *     BracketedExpression returns Variable
	 *     InsideBracketsExpression returns Variable
	 *     Or returns Variable
	 *     Or.Or_1_0 returns Variable
	 *     And returns Variable
	 *     And.And_1_0 returns Variable
	 *     Equality returns Variable
	 *     Equality.Equality_1_0 returns Variable
	 *     Comparison returns Variable
	 *     Comparison.Comparison_1_0 returns Variable
	 *     UnaryOp returns Variable
	 *     Blank returns Variable
	 *     VariableDereference returns Variable
	 *     DotDereference returns Variable
	 *     DotDereference.VariableDereference_1_0 returns Variable
	 *     ArrayDereference returns Variable
	 *     ArrayDereference.VariableDereference_1_0 returns Variable
	 *     Primary returns Variable
	 *     Atomic returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VariablesPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VariablesPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Cancelled
	 *     Expression returns Cancelled
	 *     Concat returns Cancelled
	 *     Concat.Concat_1_0 returns Cancelled
	 *     ConcatExpression returns Cancelled
	 *     BracketedExpression returns Cancelled
	 *     InsideBracketsExpression returns Cancelled
	 *     Or returns Cancelled
	 *     Or.Or_1_0 returns Cancelled
	 *     And returns Cancelled
	 *     And.And_1_0 returns Cancelled
	 *     Equality returns Cancelled
	 *     Equality.Equality_1_0 returns Cancelled
	 *     Comparison returns Cancelled
	 *     Comparison.Comparison_1_0 returns Cancelled
	 *     UnaryOp returns Cancelled
	 *     Blank returns Cancelled
	 *     VariableDereference returns Cancelled
	 *     DotDereference returns Cancelled
	 *     DotDereference.VariableDereference_1_0 returns Cancelled
	 *     ArrayDereference returns Cancelled
	 *     ArrayDereference.VariableDereference_1_0 returns Cancelled
	 *     Primary returns Cancelled
	 *     CallExpression returns Cancelled
	 *     Cancelled returns Cancelled
	 *
	 * Constraint:
	 *     {Cancelled}
	 * </pre>
	 */
	protected void sequence_Cancelled(ISerializationContext context, Cancelled semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Command
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (
	 *         id=YAML_STRING | 
	 *         if=IfStatement | 
	 *         name=Expression | 
	 *         shell=Expression | 
	 *         workingDirectory=Expression | 
	 *         environmentVariables+=VariableAssignment | 
	 *         continueOnError=Expression | 
	 *         (timeoutMinutes=Expression? command=Expression)
	 *     )+
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Comparison
	 *     Expression returns Comparison
	 *     Concat returns Comparison
	 *     Concat.Concat_1_0 returns Comparison
	 *     ConcatExpression returns Comparison
	 *     BracketedExpression returns Comparison
	 *     InsideBracketsExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     UnaryOp returns Comparison
	 *     Blank returns Comparison
	 *     VariableDereference returns Comparison
	 *     DotDereference returns Comparison
	 *     DotDereference.VariableDereference_1_0 returns Comparison
	 *     ArrayDereference returns Comparison
	 *     ArrayDereference.VariableDereference_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (lhs=Comparison_Comparison_1_0 op=COMPARISON_OP rhs=UnaryOp)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, ComparisonOperatorsPackage.Literals.COMPARISON__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComparisonOperatorsPackage.Literals.COMPARISON__OP));
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonAccess().getOpCOMPARISON_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRhsUnaryOpParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Concat
	 *     Expression returns Concat
	 *     Concat returns Concat
	 *     Concat.Concat_1_0 returns Concat
	 *
	 * Constraint:
	 *     (lhs=Concat_Concat_1_0 rhs=ConcatExpression)
	 * </pre>
	 */
	protected void sequence_Concat(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatAccess().getConcatLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getConcatAccess().getRhsConcatExpressionParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConcurrencyGroup returns ConcurrencyGroup
	 *
	 * Constraint:
	 *     (name=Expression | cancelInProgress=Expression)*
	 * </pre>
	 */
	protected void sequence_ConcurrencyGroup(ISerializationContext context, ConcurrencyGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             image=Expression | 
	 *             environmentVariables+=VariableAssignment | 
	 *             ports+=Expression | 
	 *             ports+=Expression | 
	 *             volumes+=Expression | 
	 *             volumes+=Expression | 
	 *             options=Expression | 
	 *             username=Expression | 
	 *             password=Expression
	 *         )? 
	 *         (ports+=Expression ports+=Expression*)? 
	 *         (volumes+=Expression volumes+=Expression*)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Contains
	 *     Expression returns Contains
	 *     Concat returns Contains
	 *     Concat.Concat_1_0 returns Contains
	 *     ConcatExpression returns Contains
	 *     BracketedExpression returns Contains
	 *     InsideBracketsExpression returns Contains
	 *     Or returns Contains
	 *     Or.Or_1_0 returns Contains
	 *     And returns Contains
	 *     And.And_1_0 returns Contains
	 *     Equality returns Contains
	 *     Equality.Equality_1_0 returns Contains
	 *     Comparison returns Contains
	 *     Comparison.Comparison_1_0 returns Contains
	 *     UnaryOp returns Contains
	 *     Blank returns Contains
	 *     VariableDereference returns Contains
	 *     DotDereference returns Contains
	 *     DotDereference.VariableDereference_1_0 returns Contains
	 *     ArrayDereference returns Contains
	 *     ArrayDereference.VariableDereference_1_0 returns Contains
	 *     Primary returns Contains
	 *     CallExpression returns Contains
	 *     Contains returns Contains
	 *
	 * Constraint:
	 *     (search=InsideBracketsExpression item=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_Contains(ISerializationContext context, Contains semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.CONTAINS__SEARCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.CONTAINS__SEARCH));
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.CONTAINS__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.CONTAINS__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainsAccess().getSearchInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearch());
		feeder.accept(grammarAccess.getContainsAccess().getItemInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Defaults returns Defaults
	 *
	 * Constraint:
	 *     (shell=Expression | workingDirectory=Expression)+
	 * </pre>
	 */
	protected void sequence_Defaults(ISerializationContext context, Defaults semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns EndsWith
	 *     Expression returns EndsWith
	 *     Concat returns EndsWith
	 *     Concat.Concat_1_0 returns EndsWith
	 *     ConcatExpression returns EndsWith
	 *     BracketedExpression returns EndsWith
	 *     InsideBracketsExpression returns EndsWith
	 *     Or returns EndsWith
	 *     Or.Or_1_0 returns EndsWith
	 *     And returns EndsWith
	 *     And.And_1_0 returns EndsWith
	 *     Equality returns EndsWith
	 *     Equality.Equality_1_0 returns EndsWith
	 *     Comparison returns EndsWith
	 *     Comparison.Comparison_1_0 returns EndsWith
	 *     UnaryOp returns EndsWith
	 *     Blank returns EndsWith
	 *     VariableDereference returns EndsWith
	 *     DotDereference returns EndsWith
	 *     DotDereference.VariableDereference_1_0 returns EndsWith
	 *     ArrayDereference returns EndsWith
	 *     ArrayDereference.VariableDereference_1_0 returns EndsWith
	 *     Primary returns EndsWith
	 *     CallExpression returns EndsWith
	 *     EndsWith returns EndsWith
	 *
	 * Constraint:
	 *     (searchString=InsideBracketsExpression searchValue=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_EndsWith(ISerializationContext context, EndsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.ENDS_WITH__SEARCH_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.ENDS_WITH__SEARCH_STRING));
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.ENDS_WITH__SEARCH_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.ENDS_WITH__SEARCH_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndsWithAccess().getSearchStringInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearchString());
		feeder.accept(grammarAccess.getEndsWithAccess().getSearchValueInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getSearchValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Equality
	 *     Expression returns Equality
	 *     Concat returns Equality
	 *     Concat.Concat_1_0 returns Equality
	 *     ConcatExpression returns Equality
	 *     BracketedExpression returns Equality
	 *     InsideBracketsExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     UnaryOp returns Equality
	 *     Blank returns Equality
	 *     VariableDereference returns Equality
	 *     DotDereference returns Equality
	 *     DotDereference.VariableDereference_1_0 returns Equality
	 *     ArrayDereference returns Equality
	 *     ArrayDereference.VariableDereference_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (lhs=Equality_Equality_1_0 op=EQUALITY_OP rhs=Comparison)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, EqualityOperatorsPackage.Literals.EQUALITY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EqualityOperatorsPackage.Literals.EQUALITY__OP));
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getEqualityAccess().getOpEQUALITY_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRhsComparisonParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Failure
	 *     Expression returns Failure
	 *     Concat returns Failure
	 *     Concat.Concat_1_0 returns Failure
	 *     ConcatExpression returns Failure
	 *     BracketedExpression returns Failure
	 *     InsideBracketsExpression returns Failure
	 *     Or returns Failure
	 *     Or.Or_1_0 returns Failure
	 *     And returns Failure
	 *     And.And_1_0 returns Failure
	 *     Equality returns Failure
	 *     Equality.Equality_1_0 returns Failure
	 *     Comparison returns Failure
	 *     Comparison.Comparison_1_0 returns Failure
	 *     UnaryOp returns Failure
	 *     Blank returns Failure
	 *     VariableDereference returns Failure
	 *     DotDereference returns Failure
	 *     DotDereference.VariableDereference_1_0 returns Failure
	 *     ArrayDereference returns Failure
	 *     ArrayDereference.VariableDereference_1_0 returns Failure
	 *     Primary returns Failure
	 *     CallExpression returns Failure
	 *     Failure returns Failure
	 *
	 * Constraint:
	 *     {Failure}
	 * </pre>
	 */
	protected void sequence_Failure(ISerializationContext context, Failure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Format
	 *     Expression returns Format
	 *     Concat returns Format
	 *     Concat.Concat_1_0 returns Format
	 *     ConcatExpression returns Format
	 *     BracketedExpression returns Format
	 *     InsideBracketsExpression returns Format
	 *     Or returns Format
	 *     Or.Or_1_0 returns Format
	 *     And returns Format
	 *     And.And_1_0 returns Format
	 *     Equality returns Format
	 *     Equality.Equality_1_0 returns Format
	 *     Comparison returns Format
	 *     Comparison.Comparison_1_0 returns Format
	 *     UnaryOp returns Format
	 *     Blank returns Format
	 *     VariableDereference returns Format
	 *     DotDereference returns Format
	 *     DotDereference.VariableDereference_1_0 returns Format
	 *     ArrayDereference returns Format
	 *     ArrayDereference.VariableDereference_1_0 returns Format
	 *     Primary returns Format
	 *     CallExpression returns Format
	 *     Format returns Format
	 *
	 * Constraint:
	 *     (string=InsideBracketsExpression replaceValues+=InsideBracketsExpression*)
	 * </pre>
	 */
	protected void sequence_Format(ISerializationContext context, Format semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns FromJSON
	 *     Expression returns FromJSON
	 *     Concat returns FromJSON
	 *     Concat.Concat_1_0 returns FromJSON
	 *     ConcatExpression returns FromJSON
	 *     BracketedExpression returns FromJSON
	 *     InsideBracketsExpression returns FromJSON
	 *     Or returns FromJSON
	 *     Or.Or_1_0 returns FromJSON
	 *     And returns FromJSON
	 *     And.And_1_0 returns FromJSON
	 *     Equality returns FromJSON
	 *     Equality.Equality_1_0 returns FromJSON
	 *     Comparison returns FromJSON
	 *     Comparison.Comparison_1_0 returns FromJSON
	 *     UnaryOp returns FromJSON
	 *     Blank returns FromJSON
	 *     VariableDereference returns FromJSON
	 *     DotDereference returns FromJSON
	 *     DotDereference.VariableDereference_1_0 returns FromJSON
	 *     ArrayDereference returns FromJSON
	 *     ArrayDereference.VariableDereference_1_0 returns FromJSON
	 *     Primary returns FromJSON
	 *     CallExpression returns FromJSON
	 *     FromJSON returns FromJSON
	 *
	 * Constraint:
	 *     value=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_FromJSON(ISerializationContext context, FromJSON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.FROM_JSON__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.FROM_JSON__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromJSONAccess().getValueInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns HashFiles
	 *     Expression returns HashFiles
	 *     Concat returns HashFiles
	 *     Concat.Concat_1_0 returns HashFiles
	 *     ConcatExpression returns HashFiles
	 *     BracketedExpression returns HashFiles
	 *     InsideBracketsExpression returns HashFiles
	 *     Or returns HashFiles
	 *     Or.Or_1_0 returns HashFiles
	 *     And returns HashFiles
	 *     And.And_1_0 returns HashFiles
	 *     Equality returns HashFiles
	 *     Equality.Equality_1_0 returns HashFiles
	 *     Comparison returns HashFiles
	 *     Comparison.Comparison_1_0 returns HashFiles
	 *     UnaryOp returns HashFiles
	 *     Blank returns HashFiles
	 *     VariableDereference returns HashFiles
	 *     DotDereference returns HashFiles
	 *     DotDereference.VariableDereference_1_0 returns HashFiles
	 *     ArrayDereference returns HashFiles
	 *     ArrayDereference.VariableDereference_1_0 returns HashFiles
	 *     Primary returns HashFiles
	 *     CallExpression returns HashFiles
	 *     HashFiles returns HashFiles
	 *
	 * Constraint:
	 *     path=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_HashFiles(ISerializationContext context, HashFiles semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.HASH_FILES__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.HASH_FILES__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHashFilesAccess().getPathInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (
	 *         (id=YAML_STRING description=Expression?) | 
	 *         default=Expression | 
	 *         isRequired=Expression | 
	 *         type=TYPE | 
	 *         options+=YAML_STRING | 
	 *         (options+=YAML_STRING options+=YAML_STRING*) | 
	 *         options+=YAML_STRING
	 *     )+
	 * </pre>
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Join
	 *     Expression returns Join
	 *     Concat returns Join
	 *     Concat.Concat_1_0 returns Join
	 *     ConcatExpression returns Join
	 *     BracketedExpression returns Join
	 *     InsideBracketsExpression returns Join
	 *     Or returns Join
	 *     Or.Or_1_0 returns Join
	 *     And returns Join
	 *     And.And_1_0 returns Join
	 *     Equality returns Join
	 *     Equality.Equality_1_0 returns Join
	 *     Comparison returns Join
	 *     Comparison.Comparison_1_0 returns Join
	 *     UnaryOp returns Join
	 *     Blank returns Join
	 *     VariableDereference returns Join
	 *     DotDereference returns Join
	 *     DotDereference.VariableDereference_1_0 returns Join
	 *     ArrayDereference returns Join
	 *     ArrayDereference.VariableDereference_1_0 returns Join
	 *     Primary returns Join
	 *     CallExpression returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (array=InsideBracketsExpression sep=InsideBracketsExpression?)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixAxis returns MatrixAxis
	 *
	 * Constraint:
	 *     (name=YAML_STRING (cells+=Expression | (cells+=Expression cells+=Expression*) | cells+=Expression+))
	 * </pre>
	 */
	protected void sequence_MatrixAxis(ISerializationContext context, MatrixAxis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixCombination returns MatrixCombination
	 *
	 * Constraint:
	 *     entries+=VariableAssignment
	 * </pre>
	 */
	protected void sequence_MatrixCombination(ISerializationContext context, MatrixCombination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Not
	 *     Expression returns Not
	 *     Concat returns Not
	 *     Concat.Concat_1_0 returns Not
	 *     ConcatExpression returns Not
	 *     BracketedExpression returns Not
	 *     InsideBracketsExpression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     UnaryOp returns Not
	 *     Not returns Not
	 *     Blank returns Not
	 *     VariableDereference returns Not
	 *     DotDereference returns Not
	 *     DotDereference.VariableDereference_1_0 returns Not
	 *     ArrayDereference returns Not
	 *     ArrayDereference.VariableDereference_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     childExpr=VariableDereference
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnaryOperatorsPackage.Literals.UNARY_OP__CHILD_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnaryOperatorsPackage.Literals.UNARY_OP__CHILD_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getChildExprVariableDereferenceParserRuleCall_1_0(), semanticObject.getChildExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns PullRequestTrigger
	 *     OptionedPullRequestTrigger returns PullRequestTrigger
	 *
	 * Constraint:
	 *     (
	 *         (eventTypes+=WEBHOOK_ACTIVITY_TYPE | eventTypes+=WEBHOOK_ACTIVITY_TYPE | branches+=Expression | paths+=Expression)? 
	 *         (branches+=Expression branches+=Expression*)? 
	 *         (paths+=Expression paths+=Expression*)? 
	 *         (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*)? 
	 *         (ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression)? 
	 *         (ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_OptionedPullRequestTrigger(ISerializationContext context, PullRequestTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns PushTrigger
	 *     OptionedPushTrigger returns PushTrigger
	 *
	 * Constraint:
	 *     (
	 *         (branches+=Expression | paths+=Expression | tags+=Expression)? 
	 *         (paths+=Expression paths+=Expression*)? 
	 *         (tags+=Expression tags+=Expression*)? 
	 *         (branches+=Expression branches+=Expression*)? 
	 *         (ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression)? 
	 *         (ignoreSpecifiedTags?='tags-ignore'? tags+=Expression)? 
	 *         (ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_OptionedPushTrigger(ISerializationContext context, PushTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns ScheduleTrigger
	 *     OptionedScheduleTrigger returns ScheduleTrigger
	 *
	 * Constraint:
	 *     crons+=Expression+
	 * </pre>
	 */
	protected void sequence_OptionedScheduleTrigger(ISerializationContext context, ScheduleTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns StandardEventTrigger
	 *     OptionedStandardEventTrigger returns StandardEventTrigger
	 *
	 * Constraint:
	 *     (
	 *         (event=EVENT eventTypes+=WEBHOOK_ACTIVITY_TYPE) | 
	 *         (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*) | 
	 *         eventTypes+=WEBHOOK_ACTIVITY_TYPE+
	 *     )
	 * </pre>
	 */
	protected void sequence_OptionedStandardEventTrigger(ISerializationContext context, StandardEventTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowCallTrigger
	 *     OptionedWorkflowCallTrigger returns WorkflowCallTrigger
	 *
	 * Constraint:
	 *     (inputs+=Input | outputs+=Output | secrets+=Secret)*
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowCallTrigger(ISerializationContext context, WorkflowCallTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowDispatchTrigger
	 *     OptionedWorkflowDispatchTrigger returns WorkflowDispatchTrigger
	 *
	 * Constraint:
	 *     inputs+=Input*
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowDispatchTrigger(ISerializationContext context, WorkflowDispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowRunTrigger
	 *     OptionedWorkflowRunTrigger returns WorkflowRunTrigger
	 *
	 * Constraint:
	 *     ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression+)
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowRunTrigger(ISerializationContext context, WorkflowRunTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Or
	 *     Expression returns Or
	 *     Concat returns Or
	 *     Concat.Concat_1_0 returns Or
	 *     ConcatExpression returns Or
	 *     BracketedExpression returns Or
	 *     InsideBracketsExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     UnaryOp returns Or
	 *     Blank returns Or
	 *     VariableDereference returns Or
	 *     DotDereference returns Or
	 *     DotDereference.VariableDereference_1_0 returns Or
	 *     ArrayDereference returns Or
	 *     ArrayDereference.VariableDereference_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (lhs=Or_Or_1_0 rhs=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BinaryOperatorsPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getOrAccess().getRhsAndParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     ((id=YAML_STRING description=Expression?) | value=Expression)+
	 * </pre>
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             id=YAML_STRING | 
	 *             if=IfStatement | 
	 *             name=Expression | 
	 *             shell=Expression | 
	 *             workingDirectory=Expression | 
	 *             environmentVariables+=VariableAssignment | 
	 *             continueOnError=Expression | 
	 *             entrypoint=Expression | 
	 *             containerArgs=Expression | 
	 *             args+=VariableAssignment
	 *         )? 
	 *         (timeoutMinutes=Expression? uses=Expression)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, GHA.Jobs.Steps.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Permission returns Permission
	 *
	 * Constraint:
	 *     (key=PERMISSION_SCOPE value=PERMISSION_VALUE)
	 * </pre>
	 */
	protected void sequence_Permission(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, OptionsPackage.Literals.PERMISSION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OptionsPackage.Literals.PERMISSION__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, OptionsPackage.Literals.PERMISSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OptionsPackage.Literals.PERMISSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getPermissionAccess().getKeyPERMISSION_SCOPEEnumRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPermissionAccess().getValuePERMISSION_VALUEEnumRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns ReuseWorkflowJob
	 *     ReuseWorkflowJob returns ReuseWorkflowJob
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             permissions+=Permission | 
	 *             dependsOn+=[Job|ID] | 
	 *             dependsOn+=[Job|ID] | 
	 *             if=IfStatement | 
	 *             agent=Agent | 
	 *             stagingEnvironment=StagingEnvironment | 
	 *             concurrencyGroup=ConcurrencyGroup | 
	 *             environmentVariables+=VariableAssignment | 
	 *             defaults=Defaults | 
	 *             strategy=Strategy | 
	 *             container=Container | 
	 *             services+=Service | 
	 *             workflowPath=Expression | 
	 *             args+=VariableAssignment | 
	 *             inheritSecrets?='inherit' | 
	 *             secrets+=VariableAssignment | 
	 *             continueOnError=Expression | 
	 *             timeoutMinutes=Expression
	 *         )? 
	 *         (dependsOn+=[Job|ID] dependsOn+=[Job|ID]*)? 
	 *         (name=YAML_STRING jobName=Expression?)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_ReuseWorkflowJob(ISerializationContext context, ReuseWorkflowJob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns ScriptJob
	 *     ScriptJob returns ScriptJob
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             permissions+=Permission | 
	 *             dependsOn+=[Job|ID] | 
	 *             dependsOn+=[Job|ID] | 
	 *             if=IfStatement | 
	 *             agent=Agent | 
	 *             stagingEnvironment=StagingEnvironment | 
	 *             concurrencyGroup=ConcurrencyGroup | 
	 *             environmentVariables+=VariableAssignment | 
	 *             defaults=Defaults | 
	 *             steps+=Step | 
	 *             strategy=Strategy | 
	 *             container=Container | 
	 *             services+=Service | 
	 *             continueOnError=Expression | 
	 *             timeoutMinutes=Expression
	 *         )? 
	 *         (dependsOn+=[Job|ID] dependsOn+=[Job|ID]*)? 
	 *         (name=YAML_STRING jobName=Expression?)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_ScriptJob(ISerializationContext context, ScriptJob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Secret returns Secret
	 *
	 * Constraint:
	 *     (isRequired=Expression? (id=YAML_STRING description=Expression?)?)+
	 * </pre>
	 */
	protected void sequence_Secret(ISerializationContext context, Secret semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (key=YAML_STRING value=Container)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, JobsPackage.Literals.SERVICE__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, JobsPackage.Literals.SERVICE__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, JobsPackage.Literals.SERVICE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, JobsPackage.Literals.SERVICE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getServiceAccess().getKeyYAML_STRINGTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getServiceAccess().getValueContainerParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns PullRequestTrigger
	 *     SimplePullRequestTrigger returns PullRequestTrigger
	 *
	 * Constraint:
	 *     {PullRequestTrigger}
	 * </pre>
	 */
	protected void sequence_SimplePullRequestTrigger(ISerializationContext context, PullRequestTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns PushTrigger
	 *     SimplePushTriggerTrigger returns PushTrigger
	 *
	 * Constraint:
	 *     {PushTrigger}
	 * </pre>
	 */
	protected void sequence_SimplePushTriggerTrigger(ISerializationContext context, PushTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns StandardEventTrigger
	 *     SimpleStandardEventTrigger returns StandardEventTrigger
	 *
	 * Constraint:
	 *     event=EVENT
	 * </pre>
	 */
	protected void sequence_SimpleStandardEventTrigger(ISerializationContext context, StandardEventTrigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TriggersPackage.Literals.STANDARD_EVENT_TRIGGER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TriggersPackage.Literals.STANDARD_EVENT_TRIGGER__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStandardEventTriggerAccess().getEventEVENTEnumRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns WorkflowCallTrigger
	 *     SimpleWorkflowCallTrigger returns WorkflowCallTrigger
	 *
	 * Constraint:
	 *     {WorkflowCallTrigger}
	 * </pre>
	 */
	protected void sequence_SimpleWorkflowCallTrigger(ISerializationContext context, WorkflowCallTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns WorkflowDispatchTrigger
	 *     SimpleWorkflowDispatchTrigger returns WorkflowDispatchTrigger
	 *
	 * Constraint:
	 *     {WorkflowDispatchTrigger}
	 * </pre>
	 */
	protected void sequence_SimpleWorkflowDispatchTrigger(ISerializationContext context, WorkflowDispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StagingEnvironment returns StagingEnvironment
	 *
	 * Constraint:
	 *     (name=Expression | (name=Expression url=Expression?))
	 * </pre>
	 */
	protected void sequence_StagingEnvironment(ISerializationContext context, StagingEnvironment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns StartsWith
	 *     Expression returns StartsWith
	 *     Concat returns StartsWith
	 *     Concat.Concat_1_0 returns StartsWith
	 *     ConcatExpression returns StartsWith
	 *     BracketedExpression returns StartsWith
	 *     InsideBracketsExpression returns StartsWith
	 *     Or returns StartsWith
	 *     Or.Or_1_0 returns StartsWith
	 *     And returns StartsWith
	 *     And.And_1_0 returns StartsWith
	 *     Equality returns StartsWith
	 *     Equality.Equality_1_0 returns StartsWith
	 *     Comparison returns StartsWith
	 *     Comparison.Comparison_1_0 returns StartsWith
	 *     UnaryOp returns StartsWith
	 *     Blank returns StartsWith
	 *     VariableDereference returns StartsWith
	 *     DotDereference returns StartsWith
	 *     DotDereference.VariableDereference_1_0 returns StartsWith
	 *     ArrayDereference returns StartsWith
	 *     ArrayDereference.VariableDereference_1_0 returns StartsWith
	 *     Primary returns StartsWith
	 *     CallExpression returns StartsWith
	 *     StartsWith returns StartsWith
	 *
	 * Constraint:
	 *     (searchString=InsideBracketsExpression searchValue=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_StartsWith(ISerializationContext context, StartsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.STARTS_WITH__SEARCH_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.STARTS_WITH__SEARCH_STRING));
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.STARTS_WITH__SEARCH_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.STARTS_WITH__SEARCH_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartsWithAccess().getSearchStringInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearchString());
		feeder.accept(grammarAccess.getStartsWithAccess().getSearchValueInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getSearchValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Strategy returns Matrix
	 *
	 * Constraint:
	 *     (includes+=MatrixCombination | excludes+=MatrixCombination | axes+=MatrixAxis | failFast=Expression | maxParallel=Expression)*
	 * </pre>
	 */
	protected void sequence_Strategy(ISerializationContext context, Matrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Success
	 *     Expression returns Success
	 *     Concat returns Success
	 *     Concat.Concat_1_0 returns Success
	 *     ConcatExpression returns Success
	 *     BracketedExpression returns Success
	 *     InsideBracketsExpression returns Success
	 *     Or returns Success
	 *     Or.Or_1_0 returns Success
	 *     And returns Success
	 *     And.And_1_0 returns Success
	 *     Equality returns Success
	 *     Equality.Equality_1_0 returns Success
	 *     Comparison returns Success
	 *     Comparison.Comparison_1_0 returns Success
	 *     UnaryOp returns Success
	 *     Blank returns Success
	 *     VariableDereference returns Success
	 *     DotDereference returns Success
	 *     DotDereference.VariableDereference_1_0 returns Success
	 *     ArrayDereference returns Success
	 *     ArrayDereference.VariableDereference_1_0 returns Success
	 *     Primary returns Success
	 *     CallExpression returns Success
	 *     Success returns Success
	 *
	 * Constraint:
	 *     {Success}
	 * </pre>
	 */
	protected void sequence_Success(ISerializationContext context, Success semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns ToJSON
	 *     Expression returns ToJSON
	 *     Concat returns ToJSON
	 *     Concat.Concat_1_0 returns ToJSON
	 *     ConcatExpression returns ToJSON
	 *     BracketedExpression returns ToJSON
	 *     InsideBracketsExpression returns ToJSON
	 *     Or returns ToJSON
	 *     Or.Or_1_0 returns ToJSON
	 *     And returns ToJSON
	 *     And.And_1_0 returns ToJSON
	 *     Equality returns ToJSON
	 *     Equality.Equality_1_0 returns ToJSON
	 *     Comparison returns ToJSON
	 *     Comparison.Comparison_1_0 returns ToJSON
	 *     UnaryOp returns ToJSON
	 *     Blank returns ToJSON
	 *     VariableDereference returns ToJSON
	 *     DotDereference returns ToJSON
	 *     DotDereference.VariableDereference_1_0 returns ToJSON
	 *     ArrayDereference returns ToJSON
	 *     ArrayDereference.VariableDereference_1_0 returns ToJSON
	 *     Primary returns ToJSON
	 *     CallExpression returns ToJSON
	 *     ToJSON returns ToJSON
	 *
	 * Constraint:
	 *     value=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_ToJSON(ISerializationContext context, ToJSON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BuiltInFunctionsPackage.Literals.TO_JSON__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BuiltInFunctionsPackage.Literals.TO_JSON__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToJSONAccess().getValueInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnbracketedLiteral returns StringLiteral
	 *     UnbracketedString returns StringLiteral
	 *
	 * Constraint:
	 *     value=YAML_STRING
	 * </pre>
	 */
	protected void sequence_UnbracketedString(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LiteralsPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LiteralsPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnbracketedStringAccess().getValueYAML_STRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableAssignment returns VariableAssignment
	 *
	 * Constraint:
	 *     (key=YAML_STRING value=Expression)
	 * </pre>
	 */
	protected void sequence_VariableAssignment(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ExpressionsPackage.Literals.VARIABLE_ASSIGNMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExpressionsPackage.Literals.VARIABLE_ASSIGNMENT__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, ExpressionsPackage.Literals.VARIABLE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExpressionsPackage.Literals.VARIABLE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getKeyYAML_STRINGTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (
	 *         name=Expression | 
	 *         runName=Expression | 
	 *         triggers+=SimpleTrigger | 
	 *         (triggers+=SimpleTrigger triggers+=SimpleTrigger*) | 
	 *         triggers+=SimpleTrigger | 
	 *         triggers+=OptionedTrigger | 
	 *         permissions+=Permission | 
	 *         environmentVariables+=VariableAssignment | 
	 *         defaults=Defaults | 
	 *         concurrencyGroup=ConcurrencyGroup | 
	 *         jobs+=Job
	 *     )+
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
