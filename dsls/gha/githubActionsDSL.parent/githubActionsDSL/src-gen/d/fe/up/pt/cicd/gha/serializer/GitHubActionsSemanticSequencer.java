/*
 * generated by Xtext 2.33.0
 */
package d.fe.up.pt.cicd.gha.serializer;

import GHA.Agent;
import GHA.Always;
import GHA.And;
import GHA.BooleanLiteral;
import GHA.Cancelled;
import GHA.Command;
import GHA.Comparison;
import GHA.Concat;
import GHA.ConcurrencyGroup;
import GHA.Container;
import GHA.Contains;
import GHA.Defaults;
import GHA.DoubleLiteral;
import GHA.EndsWith;
import GHA.Equality;
import GHA.Failure;
import GHA.Format;
import GHA.FromJSON;
import GHA.GHAPackage;
import GHA.GitHubContext;
import GHA.HashFiles;
import GHA.Input;
import GHA.IntegerLiteral;
import GHA.Join;
import GHA.Matrix;
import GHA.MatrixAxis;
import GHA.MatrixCombination;
import GHA.Not;
import GHA.Or;
import GHA.Output;
import GHA.PullRequestTrigger;
import GHA.PushTrigger;
import GHA.ReuseWorkflowJob;
import GHA.ScheduleTrigger;
import GHA.ScriptJob;
import GHA.Secret;
import GHA.StagingEnvironment;
import GHA.StandardEventTrigger;
import GHA.StartsWith;
import GHA.StringLiteral;
import GHA.Success;
import GHA.ToJSON;
import GHA.Variable;
import GHA.VariableDereference;
import GHA.Workflow;
import GHA.WorkflowCallTrigger;
import GHA.WorkflowDispatchTrigger;
import GHA.WorkflowRunTrigger;
import com.google.inject.Inject;
import d.fe.up.pt.cicd.gha.services.GitHubActionsGrammarAccess;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GitHubActionsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GitHubActionsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GHAPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GHAPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case GHAPackage.ALWAYS:
				sequence_Always(context, (Always) semanticObject); 
				return; 
			case GHAPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case GHAPackage.BOOLEAN_LITERAL:
				if (rule == grammarAccess.getBracketedExpressionRule()
						|| rule == grammarAccess.getInsideBracketsExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLhsAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0()
						|| rule == grammarAccess.getUnaryOpRule()
						|| rule == grammarAccess.getBlankRule()
						|| rule == grammarAccess.getVariableDereferenceRule()
						|| action == grammarAccess.getVariableDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConcatRule()
						|| action == grammarAccess.getConcatAccess().getConcatLhsAction_1_0()
						|| rule == grammarAccess.getConcatExpressionRule()) {
					sequence_Atomic_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnbracketedLiteralRule()
						|| rule == grammarAccess.getBooleanLiteralRule()) {
					sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.CANCELLED:
				sequence_Cancelled(context, (Cancelled) semanticObject); 
				return; 
			case GHAPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case GHAPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case GHAPackage.CONCAT:
				sequence_Concat(context, (Concat) semanticObject); 
				return; 
			case GHAPackage.CONCURRENCY_GROUP:
				sequence_ConcurrencyGroup(context, (ConcurrencyGroup) semanticObject); 
				return; 
			case GHAPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case GHAPackage.CONTAINS:
				sequence_Contains(context, (Contains) semanticObject); 
				return; 
			case GHAPackage.DEFAULTS:
				sequence_Defaults(context, (Defaults) semanticObject); 
				return; 
			case GHAPackage.DOUBLE_LITERAL:
				if (rule == grammarAccess.getBracketedExpressionRule()
						|| rule == grammarAccess.getInsideBracketsExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLhsAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0()
						|| rule == grammarAccess.getUnaryOpRule()
						|| rule == grammarAccess.getBlankRule()
						|| rule == grammarAccess.getVariableDereferenceRule()
						|| action == grammarAccess.getVariableDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (DoubleLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConcatRule()
						|| action == grammarAccess.getConcatAccess().getConcatLhsAction_1_0()
						|| rule == grammarAccess.getConcatExpressionRule()) {
					sequence_Atomic_DoubleLiteral(context, (DoubleLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnbracketedLiteralRule()
						|| rule == grammarAccess.getDoubleLiteralRule()) {
					sequence_DoubleLiteral(context, (DoubleLiteral) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.ENDS_WITH:
				sequence_EndsWith(context, (EndsWith) semanticObject); 
				return; 
			case GHAPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case GHAPackage.FAILURE:
				sequence_Failure(context, (Failure) semanticObject); 
				return; 
			case GHAPackage.FORMAT:
				sequence_Format(context, (Format) semanticObject); 
				return; 
			case GHAPackage.FROM_JSON:
				sequence_FromJSON(context, (FromJSON) semanticObject); 
				return; 
			case GHAPackage.GIT_HUB_CONTEXT:
				sequence_Atomic(context, (GitHubContext) semanticObject); 
				return; 
			case GHAPackage.HASH_FILES:
				sequence_HashFiles(context, (HashFiles) semanticObject); 
				return; 
			case GHAPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case GHAPackage.INTEGER_LITERAL:
				if (rule == grammarAccess.getBracketedExpressionRule()
						|| rule == grammarAccess.getInsideBracketsExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLhsAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0()
						|| rule == grammarAccess.getUnaryOpRule()
						|| rule == grammarAccess.getBlankRule()
						|| rule == grammarAccess.getVariableDereferenceRule()
						|| action == grammarAccess.getVariableDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConcatRule()
						|| action == grammarAccess.getConcatAccess().getConcatLhsAction_1_0()
						|| rule == grammarAccess.getConcatExpressionRule()) {
					sequence_Atomic_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnbracketedLiteralRule()
						|| rule == grammarAccess.getIntegerLiteralRule()) {
					sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case GHAPackage.MATRIX:
				sequence_Strategy(context, (Matrix) semanticObject); 
				return; 
			case GHAPackage.MATRIX_AXIS:
				sequence_MatrixAxis(context, (MatrixAxis) semanticObject); 
				return; 
			case GHAPackage.MATRIX_COMBINATION:
				sequence_MatrixCombination(context, (MatrixCombination) semanticObject); 
				return; 
			case GHAPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case GHAPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case GHAPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case GHAPackage.PACKAGE:
				sequence_Package(context, (GHA.Package) semanticObject); 
				return; 
			case GHAPackage.PERMISSION:
				sequence_Permission(context, (Map.Entry) semanticObject); 
				return; 
			case GHAPackage.PULL_REQUEST_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedPullRequestTriggerRule()) {
					sequence_OptionedPullRequestTrigger(context, (PullRequestTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimplePullRequestTriggerRule()) {
					sequence_SimplePullRequestTrigger(context, (PullRequestTrigger) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.PUSH_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedPushTriggerRule()) {
					sequence_OptionedPushTrigger(context, (PushTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimplePushTriggerTriggerRule()) {
					sequence_SimplePushTriggerTrigger(context, (PushTrigger) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.REUSE_WORKFLOW_JOB:
				sequence_ReuseWorkflowJob(context, (ReuseWorkflowJob) semanticObject); 
				return; 
			case GHAPackage.SCHEDULE_TRIGGER:
				sequence_OptionedScheduleTrigger(context, (ScheduleTrigger) semanticObject); 
				return; 
			case GHAPackage.SCRIPT_JOB:
				sequence_ScriptJob(context, (ScriptJob) semanticObject); 
				return; 
			case GHAPackage.SECRET:
				sequence_Secret(context, (Secret) semanticObject); 
				return; 
			case GHAPackage.SERVICE:
				sequence_Service(context, (Map.Entry) semanticObject); 
				return; 
			case GHAPackage.STAGING_ENVIRONMENT:
				sequence_StagingEnvironment(context, (StagingEnvironment) semanticObject); 
				return; 
			case GHAPackage.STANDARD_EVENT_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedStandardEventTriggerRule()) {
					sequence_OptionedStandardEventTrigger(context, (StandardEventTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleStandardEventTriggerRule()) {
					sequence_SimpleStandardEventTrigger(context, (StandardEventTrigger) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.STARTS_WITH:
				sequence_StartsWith(context, (StartsWith) semanticObject); 
				return; 
			case GHAPackage.STRING_LITERAL:
				if (rule == grammarAccess.getBracketedExpressionRule()
						|| rule == grammarAccess.getInsideBracketsExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLhsAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0()
						|| rule == grammarAccess.getUnaryOpRule()
						|| rule == grammarAccess.getBlankRule()
						|| rule == grammarAccess.getVariableDereferenceRule()
						|| action == grammarAccess.getVariableDereferenceAccess().getVariableDereferenceVariableAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConcatRule()
						|| action == grammarAccess.getConcatAccess().getConcatLhsAction_1_0()
						|| rule == grammarAccess.getConcatExpressionRule()) {
					sequence_Atomic_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnbracketedLiteralRule()
						|| rule == grammarAccess.getStringLiteralRule()) {
					sequence_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.SUCCESS:
				sequence_Success(context, (Success) semanticObject); 
				return; 
			case GHAPackage.TO_JSON:
				sequence_ToJSON(context, (ToJSON) semanticObject); 
				return; 
			case GHAPackage.VARIABLE:
				sequence_Atomic(context, (Variable) semanticObject); 
				return; 
			case GHAPackage.VARIABLE_ASSIGNMENT:
				sequence_VariableAssignment(context, (Map.Entry) semanticObject); 
				return; 
			case GHAPackage.VARIABLE_DEREFERENCE:
				sequence_VariableDereference(context, (VariableDereference) semanticObject); 
				return; 
			case GHAPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			case GHAPackage.WORKFLOW_CALL_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedWorkflowCallTriggerRule()) {
					sequence_OptionedWorkflowCallTrigger(context, (WorkflowCallTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleWorkflowCallTriggerRule()) {
					sequence_SimpleWorkflowCallTrigger(context, (WorkflowCallTrigger) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.WORKFLOW_DISPATCH_TRIGGER:
				if (rule == grammarAccess.getOptionedTriggerRule()
						|| rule == grammarAccess.getOptionedWorkflowDispatchTriggerRule()) {
					sequence_OptionedWorkflowDispatchTrigger(context, (WorkflowDispatchTrigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTriggerRule()
						|| rule == grammarAccess.getSimpleWorkflowDispatchTriggerRule()) {
					sequence_SimpleWorkflowDispatchTrigger(context, (WorkflowDispatchTrigger) semanticObject); 
					return; 
				}
				else break;
			case GHAPackage.WORKFLOW_RUN_TRIGGER:
				sequence_OptionedWorkflowRunTrigger(context, (WorkflowRunTrigger) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (
	 *         labels+=Expression | 
	 *         (labels+=Expression labels+=Expression*) | 
	 *         labels+=Expression+ | 
	 *         ((labels+=Expression | (labels+=Expression labels+=Expression*) | labels+=Expression+) group=Expression?) | 
	 *         (group=Expression (labels+=Expression | (labels+=Expression labels+=Expression*) | labels+=Expression+)?)
	 *     )
	 * </pre>
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Always
	 *     Expression returns Always
	 *     Concat returns Always
	 *     Concat.Concat_1_0 returns Always
	 *     ConcatExpression returns Always
	 *     BracketedExpression returns Always
	 *     InsideBracketsExpression returns Always
	 *     Or returns Always
	 *     Or.Or_1_0 returns Always
	 *     And returns Always
	 *     And.And_1_0 returns Always
	 *     Equality returns Always
	 *     Equality.Equality_1_0 returns Always
	 *     Comparison returns Always
	 *     Comparison.Comparison_1_0 returns Always
	 *     UnaryOp returns Always
	 *     Blank returns Always
	 *     VariableDereference returns Always
	 *     VariableDereference.VariableDereference_1_0 returns Always
	 *     Primary returns Always
	 *     CallExpression returns Always
	 *     Always returns Always
	 *
	 * Constraint:
	 *     {Always}
	 * </pre>
	 */
	protected void sequence_Always(ISerializationContext context, Always semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns And
	 *     Expression returns And
	 *     Concat returns And
	 *     Concat.Concat_1_0 returns And
	 *     ConcatExpression returns And
	 *     BracketedExpression returns And
	 *     InsideBracketsExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     UnaryOp returns And
	 *     Blank returns And
	 *     VariableDereference returns And
	 *     VariableDereference.VariableDereference_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (lhs=And_And_1_0 rhs=Equality)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAndAccess().getRhsEqualityParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BracketedExpression returns BooleanLiteral
	 *     InsideBracketsExpression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Equality returns BooleanLiteral
	 *     Equality.Equality_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.Comparison_1_0 returns BooleanLiteral
	 *     UnaryOp returns BooleanLiteral
	 *     Blank returns BooleanLiteral
	 *     VariableDereference returns BooleanLiteral
	 *     VariableDereference.VariableDereference_1_0 returns BooleanLiteral
	 *     Primary returns BooleanLiteral
	 *     Atomic returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_4_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     Concat returns BooleanLiteral
	 *     Concat.Concat_1_0 returns BooleanLiteral
	 *     ConcatExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value?=BOOLEAN | value=BOOLEAN)
	 * </pre>
	 */
	protected void sequence_Atomic_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BracketedExpression returns DoubleLiteral
	 *     InsideBracketsExpression returns DoubleLiteral
	 *     Or returns DoubleLiteral
	 *     Or.Or_1_0 returns DoubleLiteral
	 *     And returns DoubleLiteral
	 *     And.And_1_0 returns DoubleLiteral
	 *     Equality returns DoubleLiteral
	 *     Equality.Equality_1_0 returns DoubleLiteral
	 *     Comparison returns DoubleLiteral
	 *     Comparison.Comparison_1_0 returns DoubleLiteral
	 *     UnaryOp returns DoubleLiteral
	 *     Blank returns DoubleLiteral
	 *     VariableDereference returns DoubleLiteral
	 *     VariableDereference.VariableDereference_1_0 returns DoubleLiteral
	 *     Primary returns DoubleLiteral
	 *     Atomic returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns DoubleLiteral
	 *     Expression returns DoubleLiteral
	 *     Concat returns DoubleLiteral
	 *     Concat.Concat_1_0 returns DoubleLiteral
	 *     ConcatExpression returns DoubleLiteral
	 *
	 * Constraint:
	 *     (value=DOUBLE | value=DOUBLE)
	 * </pre>
	 */
	protected void sequence_Atomic_DoubleLiteral(ISerializationContext context, DoubleLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns GitHubContext
	 *     Expression returns GitHubContext
	 *     Concat returns GitHubContext
	 *     Concat.Concat_1_0 returns GitHubContext
	 *     ConcatExpression returns GitHubContext
	 *     BracketedExpression returns GitHubContext
	 *     InsideBracketsExpression returns GitHubContext
	 *     Or returns GitHubContext
	 *     Or.Or_1_0 returns GitHubContext
	 *     And returns GitHubContext
	 *     And.And_1_0 returns GitHubContext
	 *     Equality returns GitHubContext
	 *     Equality.Equality_1_0 returns GitHubContext
	 *     Comparison returns GitHubContext
	 *     Comparison.Comparison_1_0 returns GitHubContext
	 *     UnaryOp returns GitHubContext
	 *     Blank returns GitHubContext
	 *     VariableDereference returns GitHubContext
	 *     VariableDereference.VariableDereference_1_0 returns GitHubContext
	 *     Primary returns GitHubContext
	 *     Atomic returns GitHubContext
	 *
	 * Constraint:
	 *     context=CONTEXT
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, GitHubContext semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.GIT_HUB_CONTEXT__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.GIT_HUB_CONTEXT__CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getContextCONTEXTEnumRuleCall_0_1_0(), semanticObject.getContext());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BracketedExpression returns IntegerLiteral
	 *     InsideBracketsExpression returns IntegerLiteral
	 *     Or returns IntegerLiteral
	 *     Or.Or_1_0 returns IntegerLiteral
	 *     And returns IntegerLiteral
	 *     And.And_1_0 returns IntegerLiteral
	 *     Equality returns IntegerLiteral
	 *     Equality.Equality_1_0 returns IntegerLiteral
	 *     Comparison returns IntegerLiteral
	 *     Comparison.Comparison_1_0 returns IntegerLiteral
	 *     UnaryOp returns IntegerLiteral
	 *     Blank returns IntegerLiteral
	 *     VariableDereference returns IntegerLiteral
	 *     VariableDereference.VariableDereference_1_0 returns IntegerLiteral
	 *     Primary returns IntegerLiteral
	 *     Atomic returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns IntegerLiteral
	 *     Expression returns IntegerLiteral
	 *     Concat returns IntegerLiteral
	 *     Concat.Concat_1_0 returns IntegerLiteral
	 *     ConcatExpression returns IntegerLiteral
	 *
	 * Constraint:
	 *     (value=INT | value=INT)
	 * </pre>
	 */
	protected void sequence_Atomic_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BracketedExpression returns StringLiteral
	 *     InsideBracketsExpression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     UnaryOp returns StringLiteral
	 *     Blank returns StringLiteral
	 *     VariableDereference returns StringLiteral
	 *     VariableDereference.VariableDereference_1_0 returns StringLiteral
	 *     Primary returns StringLiteral
	 *     Atomic returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Concat returns StringLiteral
	 *     Concat.Concat_1_0 returns StringLiteral
	 *     ConcatExpression returns StringLiteral
	 *
	 * Constraint:
	 *     (value=YAMLString | value=STRING)
	 * </pre>
	 */
	protected void sequence_Atomic_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Variable
	 *     Expression returns Variable
	 *     Concat returns Variable
	 *     Concat.Concat_1_0 returns Variable
	 *     ConcatExpression returns Variable
	 *     BracketedExpression returns Variable
	 *     InsideBracketsExpression returns Variable
	 *     Or returns Variable
	 *     Or.Or_1_0 returns Variable
	 *     And returns Variable
	 *     And.And_1_0 returns Variable
	 *     Equality returns Variable
	 *     Equality.Equality_1_0 returns Variable
	 *     Comparison returns Variable
	 *     Comparison.Comparison_1_0 returns Variable
	 *     UnaryOp returns Variable
	 *     Blank returns Variable
	 *     VariableDereference returns Variable
	 *     VariableDereference.VariableDereference_1_0 returns Variable
	 *     Primary returns Variable
	 *     Atomic returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnbracketedLiteral returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value?=BOOLEAN
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Cancelled
	 *     Expression returns Cancelled
	 *     Concat returns Cancelled
	 *     Concat.Concat_1_0 returns Cancelled
	 *     ConcatExpression returns Cancelled
	 *     BracketedExpression returns Cancelled
	 *     InsideBracketsExpression returns Cancelled
	 *     Or returns Cancelled
	 *     Or.Or_1_0 returns Cancelled
	 *     And returns Cancelled
	 *     And.And_1_0 returns Cancelled
	 *     Equality returns Cancelled
	 *     Equality.Equality_1_0 returns Cancelled
	 *     Comparison returns Cancelled
	 *     Comparison.Comparison_1_0 returns Cancelled
	 *     UnaryOp returns Cancelled
	 *     Blank returns Cancelled
	 *     VariableDereference returns Cancelled
	 *     VariableDereference.VariableDereference_1_0 returns Cancelled
	 *     Primary returns Cancelled
	 *     CallExpression returns Cancelled
	 *     Cancelled returns Cancelled
	 *
	 * Constraint:
	 *     {Cancelled}
	 * </pre>
	 */
	protected void sequence_Cancelled(ISerializationContext context, Cancelled semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Command
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (
	 *         id=STRING | 
	 *         ifCondition=IfStatement | 
	 *         name=Expression | 
	 *         shell=Expression | 
	 *         workingDirectory=Expression | 
	 *         environmentVariables+=VariableAssignment | 
	 *         continueOnError=Expression | 
	 *         (timeoutMinutes=Expression? command=Expression)
	 *     )+
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Comparison
	 *     Expression returns Comparison
	 *     Concat returns Comparison
	 *     Concat.Concat_1_0 returns Comparison
	 *     ConcatExpression returns Comparison
	 *     BracketedExpression returns Comparison
	 *     InsideBracketsExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     UnaryOp returns Comparison
	 *     Blank returns Comparison
	 *     VariableDereference returns Comparison
	 *     VariableDereference.VariableDereference_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (lhs=Comparison_Comparison_1_0 op=COMPARISON_OP rhs=UnaryOp)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.COMPARISON__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.COMPARISON__OP));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonAccess().getOpCOMPARISON_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRhsUnaryOpParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Concat
	 *     Expression returns Concat
	 *     Concat returns Concat
	 *     Concat.Concat_1_0 returns Concat
	 *
	 * Constraint:
	 *     (lhs=Concat_Concat_1_0 rhs=ConcatExpression)
	 * </pre>
	 */
	protected void sequence_Concat(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatAccess().getConcatLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getConcatAccess().getRhsConcatExpressionParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConcurrencyGroup returns ConcurrencyGroup
	 *
	 * Constraint:
	 *     (name=Expression | cancelInProgress=Expression)+
	 * </pre>
	 */
	protected void sequence_ConcurrencyGroup(ISerializationContext context, ConcurrencyGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (
	 *         image=Expression | 
	 *         (
	 *             (
	 *                 image=Expression | 
	 *                 environmentVariables+=VariableAssignment | 
	 *                 ports+=Expression | 
	 *                 ports+=Expression | 
	 *                 volumes+=Expression | 
	 *                 volumes+=Expression | 
	 *                 options=Expression | 
	 *                 username=Expression | 
	 *                 password=Expression
	 *             )? 
	 *             (ports+=Expression ports+=Expression*)? 
	 *             (volumes+=Expression volumes+=Expression*)?
	 *         )+
	 *     )?
	 * </pre>
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Contains
	 *     Expression returns Contains
	 *     Concat returns Contains
	 *     Concat.Concat_1_0 returns Contains
	 *     ConcatExpression returns Contains
	 *     BracketedExpression returns Contains
	 *     InsideBracketsExpression returns Contains
	 *     Or returns Contains
	 *     Or.Or_1_0 returns Contains
	 *     And returns Contains
	 *     And.And_1_0 returns Contains
	 *     Equality returns Contains
	 *     Equality.Equality_1_0 returns Contains
	 *     Comparison returns Contains
	 *     Comparison.Comparison_1_0 returns Contains
	 *     UnaryOp returns Contains
	 *     Blank returns Contains
	 *     VariableDereference returns Contains
	 *     VariableDereference.VariableDereference_1_0 returns Contains
	 *     Primary returns Contains
	 *     CallExpression returns Contains
	 *     Contains returns Contains
	 *
	 * Constraint:
	 *     (search=InsideBracketsExpression item=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_Contains(ISerializationContext context, Contains semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.CONTAINS__SEARCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.CONTAINS__SEARCH));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.CONTAINS__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.CONTAINS__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainsAccess().getSearchInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearch());
		feeder.accept(grammarAccess.getContainsAccess().getItemInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Defaults returns Defaults
	 *
	 * Constraint:
	 *     (shell=Expression | workingDirectory=Expression)+
	 * </pre>
	 */
	protected void sequence_Defaults(ISerializationContext context, Defaults semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnbracketedLiteral returns DoubleLiteral
	 *     DoubleLiteral returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 * </pre>
	 */
	protected void sequence_DoubleLiteral(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoubleLiteralAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns EndsWith
	 *     Expression returns EndsWith
	 *     Concat returns EndsWith
	 *     Concat.Concat_1_0 returns EndsWith
	 *     ConcatExpression returns EndsWith
	 *     BracketedExpression returns EndsWith
	 *     InsideBracketsExpression returns EndsWith
	 *     Or returns EndsWith
	 *     Or.Or_1_0 returns EndsWith
	 *     And returns EndsWith
	 *     And.And_1_0 returns EndsWith
	 *     Equality returns EndsWith
	 *     Equality.Equality_1_0 returns EndsWith
	 *     Comparison returns EndsWith
	 *     Comparison.Comparison_1_0 returns EndsWith
	 *     UnaryOp returns EndsWith
	 *     Blank returns EndsWith
	 *     VariableDereference returns EndsWith
	 *     VariableDereference.VariableDereference_1_0 returns EndsWith
	 *     Primary returns EndsWith
	 *     CallExpression returns EndsWith
	 *     EndsWith returns EndsWith
	 *
	 * Constraint:
	 *     (searchString=InsideBracketsExpression searchValue=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_EndsWith(ISerializationContext context, EndsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.ENDS_WITH__SEARCH_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.ENDS_WITH__SEARCH_STRING));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.ENDS_WITH__SEARCH_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.ENDS_WITH__SEARCH_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndsWithAccess().getSearchStringInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearchString());
		feeder.accept(grammarAccess.getEndsWithAccess().getSearchValueInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getSearchValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Equality
	 *     Expression returns Equality
	 *     Concat returns Equality
	 *     Concat.Concat_1_0 returns Equality
	 *     ConcatExpression returns Equality
	 *     BracketedExpression returns Equality
	 *     InsideBracketsExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     UnaryOp returns Equality
	 *     Blank returns Equality
	 *     VariableDereference returns Equality
	 *     VariableDereference.VariableDereference_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (lhs=Equality_Equality_1_0 op=EQUALITY_OP rhs=Comparison)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.EQUALITY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.EQUALITY__OP));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getEqualityAccess().getOpEQUALITY_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRhsComparisonParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Failure
	 *     Expression returns Failure
	 *     Concat returns Failure
	 *     Concat.Concat_1_0 returns Failure
	 *     ConcatExpression returns Failure
	 *     BracketedExpression returns Failure
	 *     InsideBracketsExpression returns Failure
	 *     Or returns Failure
	 *     Or.Or_1_0 returns Failure
	 *     And returns Failure
	 *     And.And_1_0 returns Failure
	 *     Equality returns Failure
	 *     Equality.Equality_1_0 returns Failure
	 *     Comparison returns Failure
	 *     Comparison.Comparison_1_0 returns Failure
	 *     UnaryOp returns Failure
	 *     Blank returns Failure
	 *     VariableDereference returns Failure
	 *     VariableDereference.VariableDereference_1_0 returns Failure
	 *     Primary returns Failure
	 *     CallExpression returns Failure
	 *     Failure returns Failure
	 *
	 * Constraint:
	 *     {Failure}
	 * </pre>
	 */
	protected void sequence_Failure(ISerializationContext context, Failure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Format
	 *     Expression returns Format
	 *     Concat returns Format
	 *     Concat.Concat_1_0 returns Format
	 *     ConcatExpression returns Format
	 *     BracketedExpression returns Format
	 *     InsideBracketsExpression returns Format
	 *     Or returns Format
	 *     Or.Or_1_0 returns Format
	 *     And returns Format
	 *     And.And_1_0 returns Format
	 *     Equality returns Format
	 *     Equality.Equality_1_0 returns Format
	 *     Comparison returns Format
	 *     Comparison.Comparison_1_0 returns Format
	 *     UnaryOp returns Format
	 *     Blank returns Format
	 *     VariableDereference returns Format
	 *     VariableDereference.VariableDereference_1_0 returns Format
	 *     Primary returns Format
	 *     CallExpression returns Format
	 *     Format returns Format
	 *
	 * Constraint:
	 *     (string=InsideBracketsExpression replaceValues+=InsideBracketsExpression*)
	 * </pre>
	 */
	protected void sequence_Format(ISerializationContext context, Format semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns FromJSON
	 *     Expression returns FromJSON
	 *     Concat returns FromJSON
	 *     Concat.Concat_1_0 returns FromJSON
	 *     ConcatExpression returns FromJSON
	 *     BracketedExpression returns FromJSON
	 *     InsideBracketsExpression returns FromJSON
	 *     Or returns FromJSON
	 *     Or.Or_1_0 returns FromJSON
	 *     And returns FromJSON
	 *     And.And_1_0 returns FromJSON
	 *     Equality returns FromJSON
	 *     Equality.Equality_1_0 returns FromJSON
	 *     Comparison returns FromJSON
	 *     Comparison.Comparison_1_0 returns FromJSON
	 *     UnaryOp returns FromJSON
	 *     Blank returns FromJSON
	 *     VariableDereference returns FromJSON
	 *     VariableDereference.VariableDereference_1_0 returns FromJSON
	 *     Primary returns FromJSON
	 *     CallExpression returns FromJSON
	 *     FromJSON returns FromJSON
	 *
	 * Constraint:
	 *     value=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_FromJSON(ISerializationContext context, FromJSON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.FROM_JSON__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.FROM_JSON__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromJSONAccess().getValueInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns HashFiles
	 *     Expression returns HashFiles
	 *     Concat returns HashFiles
	 *     Concat.Concat_1_0 returns HashFiles
	 *     ConcatExpression returns HashFiles
	 *     BracketedExpression returns HashFiles
	 *     InsideBracketsExpression returns HashFiles
	 *     Or returns HashFiles
	 *     Or.Or_1_0 returns HashFiles
	 *     And returns HashFiles
	 *     And.And_1_0 returns HashFiles
	 *     Equality returns HashFiles
	 *     Equality.Equality_1_0 returns HashFiles
	 *     Comparison returns HashFiles
	 *     Comparison.Comparison_1_0 returns HashFiles
	 *     UnaryOp returns HashFiles
	 *     Blank returns HashFiles
	 *     VariableDereference returns HashFiles
	 *     VariableDereference.VariableDereference_1_0 returns HashFiles
	 *     Primary returns HashFiles
	 *     CallExpression returns HashFiles
	 *     HashFiles returns HashFiles
	 *
	 * Constraint:
	 *     path=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_HashFiles(ISerializationContext context, HashFiles semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.HASH_FILES__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.HASH_FILES__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHashFilesAccess().getPathInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (
	 *         (id=YAMLID description=Expression?) | 
	 *         default=Expression | 
	 *         isRequired=Expression | 
	 *         type=TYPE | 
	 *         options+=STRING | 
	 *         (options+=STRING options+=STRING*) | 
	 *         options+=STRING
	 *     )+
	 * </pre>
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnbracketedLiteral returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Join
	 *     Expression returns Join
	 *     Concat returns Join
	 *     Concat.Concat_1_0 returns Join
	 *     ConcatExpression returns Join
	 *     BracketedExpression returns Join
	 *     InsideBracketsExpression returns Join
	 *     Or returns Join
	 *     Or.Or_1_0 returns Join
	 *     And returns Join
	 *     And.And_1_0 returns Join
	 *     Equality returns Join
	 *     Equality.Equality_1_0 returns Join
	 *     Comparison returns Join
	 *     Comparison.Comparison_1_0 returns Join
	 *     UnaryOp returns Join
	 *     Blank returns Join
	 *     VariableDereference returns Join
	 *     VariableDereference.VariableDereference_1_0 returns Join
	 *     Primary returns Join
	 *     CallExpression returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (array=InsideBracketsExpression sep=InsideBracketsExpression?)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixAxis returns MatrixAxis
	 *
	 * Constraint:
	 *     (name=YAMLID (cells+=Expression | (cells+=Expression cells+=Expression*) | cells+=Expression+))
	 * </pre>
	 */
	protected void sequence_MatrixAxis(ISerializationContext context, MatrixAxis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixCombination returns MatrixCombination
	 *
	 * Constraint:
	 *     entries+=VariableAssignment
	 * </pre>
	 */
	protected void sequence_MatrixCombination(ISerializationContext context, MatrixCombination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Not
	 *     Expression returns Not
	 *     Concat returns Not
	 *     Concat.Concat_1_0 returns Not
	 *     ConcatExpression returns Not
	 *     BracketedExpression returns Not
	 *     InsideBracketsExpression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     UnaryOp returns Not
	 *     Not returns Not
	 *     Blank returns Not
	 *     VariableDereference returns Not
	 *     VariableDereference.VariableDereference_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     childExpr=VariableDereference
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.UNARY_OP__CHILD_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.UNARY_OP__CHILD_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getChildExprVariableDereferenceParserRuleCall_1_0(), semanticObject.getChildExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns PullRequestTrigger
	 *     OptionedPullRequestTrigger returns PullRequestTrigger
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 (eventTypes+=WEBHOOK_ACTIVITY_TYPE | eventTypes+=WEBHOOK_ACTIVITY_TYPE) 
	 *                 (branches+=Expression branches+=Expression*)? 
	 *                 branches+=Expression* 
	 *                 (ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression)?
	 *             ) | 
	 *             (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*) | 
	 *             (ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression) | 
	 *             (paths+=Expression paths+=Expression*) | 
	 *             paths+=Expression
	 *         )+ | 
	 *         (
	 *             paths+=Expression? 
	 *             (paths+=Expression paths+=Expression*)? 
	 *             (ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression)? 
	 *             (
	 *                 ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression) 
	 *                 (eventTypes+=WEBHOOK_ACTIVITY_TYPE | (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*) | eventTypes+=WEBHOOK_ACTIVITY_TYPE+)?
	 *             )?
	 *         )+ | 
	 *         (
	 *             branches+=Expression? 
	 *             (branches+=Expression branches+=Expression*)? 
	 *             (ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression)? 
	 *             (
	 *                 ((ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression) | (paths+=Expression paths+=Expression*) | paths+=Expression) 
	 *                 (eventTypes+=WEBHOOK_ACTIVITY_TYPE | (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*) | eventTypes+=WEBHOOK_ACTIVITY_TYPE+)?
	 *             )?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_OptionedPullRequestTrigger(ISerializationContext context, PullRequestTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns PushTrigger
	 *     OptionedPushTrigger returns PushTrigger
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             tags+=Expression? 
	 *             (tags+=Expression tags+=Expression*)? 
	 *             (ignoreSpecifiedTags?='tags-ignore'? tags+=Expression)? 
	 *             (
	 *                 ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression) 
	 *                 ((ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression) | (paths+=Expression paths+=Expression*) | paths+=Expression+)?
	 *             )?
	 *         )+ | 
	 *         (
	 *             tags+=Expression? 
	 *             (tags+=Expression tags+=Expression*)? 
	 *             (ignoreSpecifiedTags?='tags-ignore'? tags+=Expression)? 
	 *             (
	 *                 ((ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression) | (paths+=Expression paths+=Expression*) | paths+=Expression) 
	 *                 ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression+)?
	 *             )?
	 *         )+ | 
	 *         (
	 *             paths+=Expression? 
	 *             (paths+=Expression paths+=Expression*)? 
	 *             (ignoreSpecifiedPaths?='paths-ignore'? paths+=Expression)? 
	 *             (
	 *                 ((ignoreSpecifiedTags?='tags-ignore'? tags+=Expression) | (tags+=Expression tags+=Expression*) | tags+=Expression) 
	 *                 ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression+)?
	 *             )?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_OptionedPushTrigger(ISerializationContext context, PushTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns ScheduleTrigger
	 *     OptionedScheduleTrigger returns ScheduleTrigger
	 *
	 * Constraint:
	 *     crons+=Expression+
	 * </pre>
	 */
	protected void sequence_OptionedScheduleTrigger(ISerializationContext context, ScheduleTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns StandardEventTrigger
	 *     OptionedStandardEventTrigger returns StandardEventTrigger
	 *
	 * Constraint:
	 *     (
	 *         (event=EVENT eventTypes+=WEBHOOK_ACTIVITY_TYPE) | 
	 *         (eventTypes+=WEBHOOK_ACTIVITY_TYPE eventTypes+=WEBHOOK_ACTIVITY_TYPE*) | 
	 *         eventTypes+=WEBHOOK_ACTIVITY_TYPE+
	 *     )
	 * </pre>
	 */
	protected void sequence_OptionedStandardEventTrigger(ISerializationContext context, StandardEventTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowCallTrigger
	 *     OptionedWorkflowCallTrigger returns WorkflowCallTrigger
	 *
	 * Constraint:
	 *     (
	 *         (secrets+=Secret? (inputs+=Input outputs+=Output*)?)+ | 
	 *         (secrets+=Secret? (outputs+=Output inputs+=Input*)?)+ | 
	 *         (outputs+=Output? (secrets+=Secret inputs+=Input*)?)+
	 *     )
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowCallTrigger(ISerializationContext context, WorkflowCallTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowDispatchTrigger
	 *     OptionedWorkflowDispatchTrigger returns WorkflowDispatchTrigger
	 *
	 * Constraint:
	 *     inputs+=Input+
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowDispatchTrigger(ISerializationContext context, WorkflowDispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OptionedTrigger returns WorkflowRunTrigger
	 *     OptionedWorkflowRunTrigger returns WorkflowRunTrigger
	 *
	 * Constraint:
	 *     ((ignoreSpecifiedBranches?='branches-ignore'? branches+=Expression) | (branches+=Expression branches+=Expression*) | branches+=Expression+)
	 * </pre>
	 */
	protected void sequence_OptionedWorkflowRunTrigger(ISerializationContext context, WorkflowRunTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Or
	 *     Expression returns Or
	 *     Concat returns Or
	 *     Concat.Concat_1_0 returns Or
	 *     ConcatExpression returns Or
	 *     BracketedExpression returns Or
	 *     InsideBracketsExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     UnaryOp returns Or
	 *     Blank returns Or
	 *     VariableDereference returns Or
	 *     VariableDereference.VariableDereference_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (lhs=Or_Or_1_0 rhs=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.BINARY_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.BINARY_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getOrAccess().getRhsAndParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     ((id=YAMLID description=Expression?) | value=Expression)+
	 * </pre>
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             id=STRING | 
	 *             ifCondition=IfStatement | 
	 *             name=Expression | 
	 *             shell=Expression | 
	 *             workingDirectory=Expression | 
	 *             environmentVariables+=VariableAssignment | 
	 *             continueOnError=Expression | 
	 *             entrypoint=Expression | 
	 *             containerArgs=Expression | 
	 *             args+=VariableAssignment
	 *         )? 
	 *         (timeoutMinutes=Expression? uses=Expression)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, GHA.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Permission returns Permission
	 *
	 * Constraint:
	 *     (key=PERMISSION_SCOPE value=PERMISSION_VALUE)
	 * </pre>
	 */
	protected void sequence_Permission(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.PERMISSION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.PERMISSION__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.PERMISSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.PERMISSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getPermissionAccess().getKeyPERMISSION_SCOPEEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPermissionAccess().getValuePERMISSION_VALUEEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns ReuseWorkflowJob
	 *     ReuseWorkflowJob returns ReuseWorkflowJob
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             permissions+=Permission | 
	 *             dependsOn+=[Job|ID] | 
	 *             dependsOn+=[Job|ID] | 
	 *             ifCondition=IfStatement | 
	 *             agent=Agent | 
	 *             stagingEnvironment=StagingEnvironment | 
	 *             concurrencyGroup=ConcurrencyGroup | 
	 *             environmentVariables+=VariableAssignment | 
	 *             defaults=Defaults | 
	 *             strategy=Strategy | 
	 *             container=Container | 
	 *             services+=Service | 
	 *             workflowPath=Expression | 
	 *             args+=VariableAssignment | 
	 *             inheritSecrets?='inherit' | 
	 *             secrets+=VariableAssignment | 
	 *             continueOnError=Expression | 
	 *             timeoutMinutes=Expression
	 *         )? 
	 *         (name=YAMLID jobName=Expression?)? 
	 *         (dependsOn+=[Job|ID] dependsOn+=[Job|ID]*)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_ReuseWorkflowJob(ISerializationContext context, ReuseWorkflowJob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns ScriptJob
	 *     ScriptJob returns ScriptJob
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             permissions+=Permission | 
	 *             dependsOn+=[Job|ID] | 
	 *             dependsOn+=[Job|ID] | 
	 *             ifCondition=IfStatement | 
	 *             agent=Agent | 
	 *             stagingEnvironment=StagingEnvironment | 
	 *             concurrencyGroup=ConcurrencyGroup | 
	 *             environmentVariables+=VariableAssignment | 
	 *             defaults=Defaults | 
	 *             steps+=Step | 
	 *             strategy=Strategy | 
	 *             container=Container | 
	 *             services+=Service | 
	 *             continueOnError=Expression | 
	 *             timeoutMinutes=Expression
	 *         )? 
	 *         (name=YAMLID jobName=Expression?)? 
	 *         (dependsOn+=[Job|ID] dependsOn+=[Job|ID]*)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_ScriptJob(ISerializationContext context, ScriptJob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Secret returns Secret
	 *
	 * Constraint:
	 *     ((id=YAMLID (description=Expression | isRequired=Expression)*) | (isRequired=Expression | description=Expression)+)
	 * </pre>
	 */
	protected void sequence_Secret(ISerializationContext context, Secret semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (key=YAMLID value=Container)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.SERVICE__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.SERVICE__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.SERVICE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.SERVICE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getServiceAccess().getKeyYAMLIDParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getServiceAccess().getValueContainerParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns PullRequestTrigger
	 *     SimplePullRequestTrigger returns PullRequestTrigger
	 *
	 * Constraint:
	 *     {PullRequestTrigger}
	 * </pre>
	 */
	protected void sequence_SimplePullRequestTrigger(ISerializationContext context, PullRequestTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns PushTrigger
	 *     SimplePushTriggerTrigger returns PushTrigger
	 *
	 * Constraint:
	 *     {PushTrigger}
	 * </pre>
	 */
	protected void sequence_SimplePushTriggerTrigger(ISerializationContext context, PushTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns StandardEventTrigger
	 *     SimpleStandardEventTrigger returns StandardEventTrigger
	 *
	 * Constraint:
	 *     event=EVENT
	 * </pre>
	 */
	protected void sequence_SimpleStandardEventTrigger(ISerializationContext context, StandardEventTrigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.STANDARD_EVENT_TRIGGER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.STANDARD_EVENT_TRIGGER__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStandardEventTriggerAccess().getEventEVENTEnumRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns WorkflowCallTrigger
	 *     SimpleWorkflowCallTrigger returns WorkflowCallTrigger
	 *
	 * Constraint:
	 *     {WorkflowCallTrigger}
	 * </pre>
	 */
	protected void sequence_SimpleWorkflowCallTrigger(ISerializationContext context, WorkflowCallTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTrigger returns WorkflowDispatchTrigger
	 *     SimpleWorkflowDispatchTrigger returns WorkflowDispatchTrigger
	 *
	 * Constraint:
	 *     {WorkflowDispatchTrigger}
	 * </pre>
	 */
	protected void sequence_SimpleWorkflowDispatchTrigger(ISerializationContext context, WorkflowDispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StagingEnvironment returns StagingEnvironment
	 *
	 * Constraint:
	 *     (name=Expression | (name=Expression url=Expression?))
	 * </pre>
	 */
	protected void sequence_StagingEnvironment(ISerializationContext context, StagingEnvironment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns StartsWith
	 *     Expression returns StartsWith
	 *     Concat returns StartsWith
	 *     Concat.Concat_1_0 returns StartsWith
	 *     ConcatExpression returns StartsWith
	 *     BracketedExpression returns StartsWith
	 *     InsideBracketsExpression returns StartsWith
	 *     Or returns StartsWith
	 *     Or.Or_1_0 returns StartsWith
	 *     And returns StartsWith
	 *     And.And_1_0 returns StartsWith
	 *     Equality returns StartsWith
	 *     Equality.Equality_1_0 returns StartsWith
	 *     Comparison returns StartsWith
	 *     Comparison.Comparison_1_0 returns StartsWith
	 *     UnaryOp returns StartsWith
	 *     Blank returns StartsWith
	 *     VariableDereference returns StartsWith
	 *     VariableDereference.VariableDereference_1_0 returns StartsWith
	 *     Primary returns StartsWith
	 *     CallExpression returns StartsWith
	 *     StartsWith returns StartsWith
	 *
	 * Constraint:
	 *     (searchString=InsideBracketsExpression searchValue=InsideBracketsExpression)
	 * </pre>
	 */
	protected void sequence_StartsWith(ISerializationContext context, StartsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.STARTS_WITH__SEARCH_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.STARTS_WITH__SEARCH_STRING));
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.STARTS_WITH__SEARCH_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.STARTS_WITH__SEARCH_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartsWithAccess().getSearchStringInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getSearchString());
		feeder.accept(grammarAccess.getStartsWithAccess().getSearchValueInsideBracketsExpressionParserRuleCall_4_0(), semanticObject.getSearchValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Strategy returns Matrix
	 *
	 * Constraint:
	 *     (includes+=MatrixCombination | excludes+=MatrixCombination | axes+=MatrixAxis | failFast=Expression | maxParallel=Expression)*
	 * </pre>
	 */
	protected void sequence_Strategy(ISerializationContext context, Matrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnbracketedLiteral returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=YAMLString
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueYAMLStringParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns Success
	 *     Expression returns Success
	 *     Concat returns Success
	 *     Concat.Concat_1_0 returns Success
	 *     ConcatExpression returns Success
	 *     BracketedExpression returns Success
	 *     InsideBracketsExpression returns Success
	 *     Or returns Success
	 *     Or.Or_1_0 returns Success
	 *     And returns Success
	 *     And.And_1_0 returns Success
	 *     Equality returns Success
	 *     Equality.Equality_1_0 returns Success
	 *     Comparison returns Success
	 *     Comparison.Comparison_1_0 returns Success
	 *     UnaryOp returns Success
	 *     Blank returns Success
	 *     VariableDereference returns Success
	 *     VariableDereference.VariableDereference_1_0 returns Success
	 *     Primary returns Success
	 *     CallExpression returns Success
	 *     Success returns Success
	 *
	 * Constraint:
	 *     {Success}
	 * </pre>
	 */
	protected void sequence_Success(ISerializationContext context, Success semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns ToJSON
	 *     Expression returns ToJSON
	 *     Concat returns ToJSON
	 *     Concat.Concat_1_0 returns ToJSON
	 *     ConcatExpression returns ToJSON
	 *     BracketedExpression returns ToJSON
	 *     InsideBracketsExpression returns ToJSON
	 *     Or returns ToJSON
	 *     Or.Or_1_0 returns ToJSON
	 *     And returns ToJSON
	 *     And.And_1_0 returns ToJSON
	 *     Equality returns ToJSON
	 *     Equality.Equality_1_0 returns ToJSON
	 *     Comparison returns ToJSON
	 *     Comparison.Comparison_1_0 returns ToJSON
	 *     UnaryOp returns ToJSON
	 *     Blank returns ToJSON
	 *     VariableDereference returns ToJSON
	 *     VariableDereference.VariableDereference_1_0 returns ToJSON
	 *     Primary returns ToJSON
	 *     CallExpression returns ToJSON
	 *     ToJSON returns ToJSON
	 *
	 * Constraint:
	 *     value=InsideBracketsExpression
	 * </pre>
	 */
	protected void sequence_ToJSON(ISerializationContext context, ToJSON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHAPackage.Literals.TO_JSON__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHAPackage.Literals.TO_JSON__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToJSONAccess().getValueInsideBracketsExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableAssignment returns VariableAssignment
	 *
	 * Constraint:
	 *     (key=YAMLID value=Expression)
	 * </pre>
	 */
	protected void sequence_VariableAssignment(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.VARIABLE_ASSIGNMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.VARIABLE_ASSIGNMENT__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, GHAPackage.Literals.VARIABLE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, GHAPackage.Literals.VARIABLE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getKeyYAMLIDParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns VariableDereference
	 *     Expression returns VariableDereference
	 *     Concat returns VariableDereference
	 *     Concat.Concat_1_0 returns VariableDereference
	 *     ConcatExpression returns VariableDereference
	 *     BracketedExpression returns VariableDereference
	 *     InsideBracketsExpression returns VariableDereference
	 *     Or returns VariableDereference
	 *     Or.Or_1_0 returns VariableDereference
	 *     And returns VariableDereference
	 *     And.And_1_0 returns VariableDereference
	 *     Equality returns VariableDereference
	 *     Equality.Equality_1_0 returns VariableDereference
	 *     Comparison returns VariableDereference
	 *     Comparison.Comparison_1_0 returns VariableDereference
	 *     UnaryOp returns VariableDereference
	 *     Blank returns VariableDereference
	 *     VariableDereference returns VariableDereference
	 *     VariableDereference.VariableDereference_1_0 returns VariableDereference
	 *     Primary returns VariableDereference
	 *
	 * Constraint:
	 *     (variable=VariableDereference_VariableDereference_1_0 (property=ID | property=ID | property=ID))
	 * </pre>
	 */
	protected void sequence_VariableDereference(ISerializationContext context, VariableDereference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (
	 *         name=Expression | 
	 *         runName=Expression | 
	 *         triggers+=SimpleTrigger | 
	 *         (triggers+=SimpleTrigger triggers+=SimpleTrigger*) | 
	 *         triggers+=SimpleTrigger | 
	 *         triggers+=OptionedTrigger | 
	 *         permissions+=Permission | 
	 *         environmentVariables+=VariableAssignment | 
	 *         defaults=Defaults | 
	 *         concurrencyGroup=ConcurrencyGroup | 
	 *         jobs+=Job
	 *     )+
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
