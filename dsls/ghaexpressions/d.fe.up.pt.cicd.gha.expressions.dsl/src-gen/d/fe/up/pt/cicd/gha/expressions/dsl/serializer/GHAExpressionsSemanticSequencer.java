/*
 * generated by Xtext 2.33.0
 */
package d.fe.up.pt.cicd.gha.expressions.dsl.serializer;

import com.google.inject.Inject;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.And;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.BooleanLiteral;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.Comparison;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.DoubleLiteral;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.Equality;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.Function;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.GhaExpressionsPackage;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.IntegerLiteral;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.Not;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.Or;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.StringLiteral;
import d.fe.up.pt.cicd.gha.expressions.dsl.ghaExpressions.VariableReference;
import d.fe.up.pt.cicd.gha.expressions.dsl.services.GHAExpressionsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GHAExpressionsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GHAExpressionsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GhaExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GhaExpressionsPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case GhaExpressionsPackage.BOOLEAN_LITERAL:
				sequence_Atomic(context, (BooleanLiteral) semanticObject); 
				return; 
			case GhaExpressionsPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case GhaExpressionsPackage.DOUBLE_LITERAL:
				sequence_Atomic(context, (DoubleLiteral) semanticObject); 
				return; 
			case GhaExpressionsPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case GhaExpressionsPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case GhaExpressionsPackage.INTEGER_LITERAL:
				sequence_Atomic(context, (IntegerLiteral) semanticObject); 
				return; 
			case GhaExpressionsPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case GhaExpressionsPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case GhaExpressionsPackage.STRING_LITERAL:
				sequence_Atomic(context, (StringLiteral) semanticObject); 
				return; 
			case GhaExpressionsPackage.VARIABLE_REFERENCE:
				sequence_Atomic(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     UnaryOp returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (lhs=And_And_1_0 rhs=Equality)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.AND__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.AND__LHS));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.AND__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.AND__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAndAccess().getRhsEqualityParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Equality returns BooleanLiteral
	 *     Equality.Equality_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.Comparison_1_0 returns BooleanLiteral
	 *     UnaryOp returns BooleanLiteral
	 *     Primary returns BooleanLiteral
	 *     Atomic returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns DoubleLiteral
	 *     Or returns DoubleLiteral
	 *     Or.Or_1_0 returns DoubleLiteral
	 *     And returns DoubleLiteral
	 *     And.And_1_0 returns DoubleLiteral
	 *     Equality returns DoubleLiteral
	 *     Equality.Equality_1_0 returns DoubleLiteral
	 *     Comparison returns DoubleLiteral
	 *     Comparison.Comparison_1_0 returns DoubleLiteral
	 *     UnaryOp returns DoubleLiteral
	 *     Primary returns DoubleLiteral
	 *     Atomic returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueDOUBLETerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     Or returns IntegerLiteral
	 *     Or.Or_1_0 returns IntegerLiteral
	 *     And returns IntegerLiteral
	 *     And.And_1_0 returns IntegerLiteral
	 *     Equality returns IntegerLiteral
	 *     Equality.Equality_1_0 returns IntegerLiteral
	 *     Comparison returns IntegerLiteral
	 *     Comparison.Comparison_1_0 returns IntegerLiteral
	 *     UnaryOp returns IntegerLiteral
	 *     Primary returns IntegerLiteral
	 *     Atomic returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     UnaryOp returns StringLiteral
	 *     Primary returns StringLiteral
	 *     Atomic returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableReference
	 *     Or returns VariableReference
	 *     Or.Or_1_0 returns VariableReference
	 *     And returns VariableReference
	 *     And.And_1_0 returns VariableReference
	 *     Equality returns VariableReference
	 *     Equality.Equality_1_0 returns VariableReference
	 *     Comparison returns VariableReference
	 *     Comparison.Comparison_1_0 returns VariableReference
	 *     UnaryOp returns VariableReference
	 *     Primary returns VariableReference
	 *     Atomic returns VariableReference
	 *
	 * Constraint:
	 *     (value=ID | value=VARIABLE_REFERENCE)
	 * </pre>
	 */
	protected void sequence_Atomic(ISerializationContext context, VariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     UnaryOp returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (lhs=Comparison_Comparison_1_0 op=COMPARISON_OP rhs=UnaryOp)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__LHS));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__OP));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.COMPARISON__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonAccess().getOpCOMPARISON_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRhsUnaryOpParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     UnaryOp returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (lhs=Equality_Equality_1_0 op=EQUALITY_OP rhs=Comparison)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__LHS));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__OP));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.EQUALITY__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getEqualityAccess().getOpEQUALITY_OPEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRhsComparisonParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Function
	 *     Or returns Function
	 *     Or.Or_1_0 returns Function
	 *     And returns Function
	 *     And.And_1_0 returns Function
	 *     Equality returns Function
	 *     Equality.Equality_1_0 returns Function
	 *     Comparison returns Function
	 *     Comparison.Comparison_1_0 returns Function
	 *     UnaryOp returns Function
	 *     Primary returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (args+=Expression args+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     UnaryOp returns Not
	 *     Not returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     childExpr=Primary
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.NOT__CHILD_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.NOT__CHILD_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getChildExprPrimaryParserRuleCall_2_0(), semanticObject.getChildExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     UnaryOp returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (lhs=Or_Or_1_0 rhs=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.OR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.OR__LHS));
			if (transientValues.isValueTransient(semanticObject, GhaExpressionsPackage.Literals.OR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GhaExpressionsPackage.Literals.OR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getOrAccess().getRhsAndParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
}
